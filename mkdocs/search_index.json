{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\nForeword\n\n\nThis document hereby refers to the content of the whole website. Any contributor is welcomed\nand could give a hand in several manners:\n\n\n\n\nLooking for and correcting typos\n\n\nAdding relevant and non redundant information\n\n\nCompleting a part marked as //TODO\n\n\n\n\nRegardless of what you'll attempt, make sure to check \nthe issues list on\nGitHub\n before doing anything\n. Thus, if nobody is already working on something\nrelated, open an issue with a clear and concise title and briefly explain your incoming changes\nin the description. Then, fork the project, do your work, and create a Pull Request on the\noriginal repository. \n\n\nTo sum up:\n\n\n\n\nCheck \nGitHub issues\n\n\nOpen a new issue if no one exist\n\n\nFork the repository\n\n\nCreate a Pull Request once you're done\n\n\n\n\nThanks a lot !\n\n\nComponents\n\n\nThe following document describe the specifications for The Things Network's Architecture\nversion 1. These specifications focus on the network architecture which includes 4 kinds of\ncomponents:\n\n\n\n\nRouters \n\n\nBrokers\n\n\nNetwork Servers\n\n\nHandlers\n\n\n\n\nAdditionally, these components interact with external entities over which we have little or no control:\n\n\n\n\nNodes (also known as end-devices)\n\n\nGateways\n\n\nApplications\n\n\n\n\n\n\n\n\nNetwork components\n\n\n\n\nNode\n\n\nNodes or end-devices refer to one end of the chain. End-devices emit signals using\n\nLoRa\n modulation and frequency range towards Gateways. They are split into\n3 classes: \n\n\n\n\nA\n: Cannot receive any data from the network unless they've initiated the communication\n\n\nB\n: Can receive data from the network at precisely scheduled windows (Beacons)\n\n\nC\n: Can receive data at any time from the network\n\n\n\n\nIncidentally, class A requires less power than B which requires less power than C. \nAn end-device has an address either assigned by the Network or self-defined. An end-device\nalso has a specific secret application session key and a network session key \n\n\nThese specifications primarly focus on the class A. Future network versions will implement\nmechanisms to handle class B and class C but they are irrevelant with the current document.\n\n\nGateway\n\n\nGateways might be seen as a way to transform multiple messages emitters into one much more\ndemanding emitter. Therefore, a Gateway gathers \nLoRa\n signals coming from a\nbunch of near end-devices. A given end-device does not need to know the nearest gateways, nor it\nhas to communicate with a specific one - signals are simply broadcasted into the wild open. \n\n\nGateways receive signals which reach them, and forward the message to a dedicated Router. The\nData could be either a sensor result or a specific network command such as a connection\nrequest. A Gateway actually sends incoming packets to a router after having wrapped each of them\ninto a \njson\n structure holding meta-data about the Gateway itself (such as Gateway's\nidentifier, a timestamp and GPS coordinates if available).\n\n\nGateways can also emit packets coming from the network toward a Node using the \nLoRa\ntechnology\n. In fact, Gateways are in charge of taking care of emission at a\nscheduled time defined by the network meaning that the network is able to send packets to\nGateways at any moment, regardless of their emission time (see more about the two-windows\nresponse mechanism //TODO add a link). \n\n\nRouter\n\n\nRouters are entry points of the network from Nodes perspective. Packets transmitted by Nodes are forwarded to a specific Router from one or several Gateways. The Router then forwards those packets\nto one or several Brokers. The communication is bi-directional: Routers may also\ntransfer packets from Broker to Gateways.\n\n\n\n\n\n\nUplink forwarding\n\n\n\n\nBroker\n\n\nBrokers have a global vision of a network's part. They are in charge of several nodes, meaning\nthat they will handle packets coming from those nodes (thereby, they are able to tell to\nRouters if they can handle a given packet). Several Routers may send packets coming from the\nsame end-device (shared by several segments / Gateways), all duplicates are managed by the\nBroker and are sent to a corresponding Handler.\n\n\nA Broker is thereby able to check the integrity of a packet and is closely communicating with a\nNetwork Server in order to administrate the related end-device. For a reference of magnitude, Brokers\nare designed to be in charge of a whole country or region (if the region has enough activity to\ndeserve a dedicated Broker).\n\n\nNetwork Server\n\n\nNetwork servers are processing \nMAC\n commands emitted by end-devices as well as taking care\nof the data rates and the frequency of the end-devices. Network Servers would emit commands to\noptimize the network by adjusting end-devices data rates / frequencies unless the node is\nrequesting to keep its configuration as is. \n\n\nFor the moment, a single Network Server will be associated for each Broker. No communication\nmechanisms between Network Servers is planned for the first version. Also, it won't be possible\nfor a Broker to query another Network Server than the one it has been assigned to. Those\nfeatures might be part of a second version. \n\n\nHandler\n\n\nHandlers materialize the entry point to the network for client Applications. They are secure\nreferees which encode and decode data coming from application before transmitting them to a\nBroker of the network. Therefore, they are in charge of handling applications secret keys and\nonly communicate an application id to Brokers as well as specific network session keys for each\nnode (described in further sections). This way, the whole chain is able to forward a packet to\nthe corresponding Handler without having any information about either the recipient (but a\nmeaningless id) or the content. \n\n\nBecause a given Handler is able to decrypt the data payload of a given packet, it could also\nimplement mechanisms such as geolocation and send to the corresponding application some\ninteresting meta-data alongside the data payload. Incidentally, a handler can only decrypt\npayload for packets related to applications registered to that handler. The handler is managing\nseveral application secret keys and use them to encrypt and decrypt corresponding packet\npayloads.\n\n\nA Handler could be either part of an application or a standalone trusty server on which\napplication may register. The Things Network will provide Handlers as part of the whole network\nbut - and this is true for any component - anyone could create its own implementation as long\nas it is compliant to the following specifications.\n\n\n\n\n\n\nUplink to an Application", 
            "title": "Overview"
        }, 
        {
            "location": "/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/#foreword", 
            "text": "This document hereby refers to the content of the whole website. Any contributor is welcomed\nand could give a hand in several manners:   Looking for and correcting typos  Adding relevant and non redundant information  Completing a part marked as //TODO   Regardless of what you'll attempt, make sure to check  the issues list on\nGitHub  before doing anything . Thus, if nobody is already working on something\nrelated, open an issue with a clear and concise title and briefly explain your incoming changes\nin the description. Then, fork the project, do your work, and create a Pull Request on the\noriginal repository.   To sum up:   Check  GitHub issues  Open a new issue if no one exist  Fork the repository  Create a Pull Request once you're done   Thanks a lot !", 
            "title": "Foreword"
        }, 
        {
            "location": "/#components", 
            "text": "The following document describe the specifications for The Things Network's Architecture\nversion 1. These specifications focus on the network architecture which includes 4 kinds of\ncomponents:   Routers   Brokers  Network Servers  Handlers   Additionally, these components interact with external entities over which we have little or no control:   Nodes (also known as end-devices)  Gateways  Applications     Network components   Node  Nodes or end-devices refer to one end of the chain. End-devices emit signals using LoRa  modulation and frequency range towards Gateways. They are split into\n3 classes:    A : Cannot receive any data from the network unless they've initiated the communication  B : Can receive data from the network at precisely scheduled windows (Beacons)  C : Can receive data at any time from the network   Incidentally, class A requires less power than B which requires less power than C. \nAn end-device has an address either assigned by the Network or self-defined. An end-device\nalso has a specific secret application session key and a network session key   These specifications primarly focus on the class A. Future network versions will implement\nmechanisms to handle class B and class C but they are irrevelant with the current document.  Gateway  Gateways might be seen as a way to transform multiple messages emitters into one much more\ndemanding emitter. Therefore, a Gateway gathers  LoRa  signals coming from a\nbunch of near end-devices. A given end-device does not need to know the nearest gateways, nor it\nhas to communicate with a specific one - signals are simply broadcasted into the wild open.   Gateways receive signals which reach them, and forward the message to a dedicated Router. The\nData could be either a sensor result or a specific network command such as a connection\nrequest. A Gateway actually sends incoming packets to a router after having wrapped each of them\ninto a  json  structure holding meta-data about the Gateway itself (such as Gateway's\nidentifier, a timestamp and GPS coordinates if available).  Gateways can also emit packets coming from the network toward a Node using the  LoRa\ntechnology . In fact, Gateways are in charge of taking care of emission at a\nscheduled time defined by the network meaning that the network is able to send packets to\nGateways at any moment, regardless of their emission time (see more about the two-windows\nresponse mechanism //TODO add a link).   Router  Routers are entry points of the network from Nodes perspective. Packets transmitted by Nodes are forwarded to a specific Router from one or several Gateways. The Router then forwards those packets\nto one or several Brokers. The communication is bi-directional: Routers may also\ntransfer packets from Broker to Gateways.    Uplink forwarding   Broker  Brokers have a global vision of a network's part. They are in charge of several nodes, meaning\nthat they will handle packets coming from those nodes (thereby, they are able to tell to\nRouters if they can handle a given packet). Several Routers may send packets coming from the\nsame end-device (shared by several segments / Gateways), all duplicates are managed by the\nBroker and are sent to a corresponding Handler.  A Broker is thereby able to check the integrity of a packet and is closely communicating with a\nNetwork Server in order to administrate the related end-device. For a reference of magnitude, Brokers\nare designed to be in charge of a whole country or region (if the region has enough activity to\ndeserve a dedicated Broker).  Network Server  Network servers are processing  MAC  commands emitted by end-devices as well as taking care\nof the data rates and the frequency of the end-devices. Network Servers would emit commands to\noptimize the network by adjusting end-devices data rates / frequencies unless the node is\nrequesting to keep its configuration as is.   For the moment, a single Network Server will be associated for each Broker. No communication\nmechanisms between Network Servers is planned for the first version. Also, it won't be possible\nfor a Broker to query another Network Server than the one it has been assigned to. Those\nfeatures might be part of a second version.   Handler  Handlers materialize the entry point to the network for client Applications. They are secure\nreferees which encode and decode data coming from application before transmitting them to a\nBroker of the network. Therefore, they are in charge of handling applications secret keys and\nonly communicate an application id to Brokers as well as specific network session keys for each\nnode (described in further sections). This way, the whole chain is able to forward a packet to\nthe corresponding Handler without having any information about either the recipient (but a\nmeaningless id) or the content.   Because a given Handler is able to decrypt the data payload of a given packet, it could also\nimplement mechanisms such as geolocation and send to the corresponding application some\ninteresting meta-data alongside the data payload. Incidentally, a handler can only decrypt\npayload for packets related to applications registered to that handler. The handler is managing\nseveral application secret keys and use them to encrypt and decrypt corresponding packet\npayloads.  A Handler could be either part of an application or a standalone trusty server on which\napplication may register. The Things Network will provide Handlers as part of the whole network\nbut - and this is true for any component - anyone could create its own implementation as long\nas it is compliant to the following specifications.    Uplink to an Application", 
            "title": "Components"
        }, 
        {
            "location": "/common/", 
            "text": "Common\n\n\nPacket representation\n\n\nAs long as all components use compatible representation of a packet, they sould be able to\ncommunicate. Therefore, when refering to a \nPacket\n, we're seemingly refering a \njson-like\n\nstructure of the following shape:\n\n\n{\n    \ntime\n: \nString\n,\n    \ntmst\n: \nNumber\n,\n    \nfreq\n: \nNumber\n,\n    \nchan\n: \nNumber\n,\n    \nrfch\n: \nNumber\n,\n    \nstat\n: \nNumber\n,\n    \nmodu\n: \nString\n,\n    \ndatr\n: \nNumber\n, // In case of GFSK modulation\n    \ndatr\n: \nString\n, // In case of LoRa modulation\n    \ncodr\n: \nString\n,\n    \nrssi\n: \nNumber\n,\n    \nlsnr\n: \nNumber\n,\n    \nsize\n: \nNumber\n,\n    \ndata\n: \nString\n\n}\n\n\n\n\nMore information about the meaning of those fields could be found in the \nsemtech protocol\ndescription\n.\n\n\nMAC Command\n\n\n//TODO\n\n\nErrors\n\n\nAny error coming from any components should provide the following information:\n\n\n\n\na name / identifier \n\n\na date (the moment it happens)\n\n\na message / description\n\n\nthe packet or data manipulated if any\n\n\n\n\nA given error will thus provide methods that reflect those attributes:\n\n\n-- Retrieve the error's name\nname :: Error -\n String\n\n-- Retrieve the error's creation date\ndate :: Error -\n Date|String\n\n-- Retrieve the error's message\nmessage :: Error -\n String\n\n-- Retrieve the error's data\nparams :: Error -\n a", 
            "title": "Common"
        }, 
        {
            "location": "/common/#common", 
            "text": "", 
            "title": "Common"
        }, 
        {
            "location": "/common/#packet-representation", 
            "text": "As long as all components use compatible representation of a packet, they sould be able to\ncommunicate. Therefore, when refering to a  Packet , we're seemingly refering a  json-like \nstructure of the following shape:  {\n     time :  String ,\n     tmst :  Number ,\n     freq :  Number ,\n     chan :  Number ,\n     rfch :  Number ,\n     stat :  Number ,\n     modu :  String ,\n     datr :  Number , // In case of GFSK modulation\n     datr :  String , // In case of LoRa modulation\n     codr :  String ,\n     rssi :  Number ,\n     lsnr :  Number ,\n     size :  Number ,\n     data :  String \n}  More information about the meaning of those fields could be found in the  semtech protocol\ndescription .", 
            "title": "Packet representation"
        }, 
        {
            "location": "/common/#mac-command", 
            "text": "//TODO", 
            "title": "MAC Command"
        }, 
        {
            "location": "/common/#errors", 
            "text": "Any error coming from any components should provide the following information:   a name / identifier   a date (the moment it happens)  a message / description  the packet or data manipulated if any   A given error will thus provide methods that reflect those attributes:  -- Retrieve the error's name\nname :: Error -  String\n\n-- Retrieve the error's creation date\ndate :: Error -  Date|String\n\n-- Retrieve the error's message\nmessage :: Error -  String\n\n-- Retrieve the error's data\nparams :: Error -  a", 
            "title": "Errors"
        }, 
        {
            "location": "/router/", 
            "text": "Router\n\n\n\n\n\n\n\n\nR\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nR-1\n\n\nForward uplink messages to brokers\n\n\n\n\n\n\nR-2\n\n\nForward downlink messages to gateways\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR-1\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nR-1.1\n\n\nListen and receive incoming uplink transmissions\n\n\n\n\n\n\nR-1.2\n\n\nDecode an incoming transmission\n\n\n\n\n\n\nR-1.3\n\n\nLookup a device address\n\n\n\n\n\n\nR-1.4\n\n\nForward a packet to broker(s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR-1.3\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nR-1.3.1\n\n\nLookup local storage addresses\n\n\n\n\n\n\nR-1.3.2\n\n\nInvalidate expired entries\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR-1.4\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nR-1.4.1\n\n\nSend a packet to known brokers\n\n\n\n\n\n\nR-1.4.2\n\n\nBroadcast a packet to all brokers\n\n\n\n\n\n\nR-1.4.3\n\n\nStore device address and associated broker(s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR-2\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nR-2.1\n\n\nListen and receive incoming downlink transmissions\n\n\n\n\n\n\nR-2.2\n\n\nDetermine recipient gateway(s)\n\n\n\n\n\n\nR-2.3\n\n\nForward a packet to gateway(s)\n\n\n\n\n\n\n\n\nRole\n\n\nThe router's role is straightforward; It has to transfer packets coming from an emitter to the\nright recipient. The emitter and the recipient could be either:\n\n\n\n\nA gateway and a broker\n\n\nA broker and a gateway\n\n\n\n\nThis implies the router is able to interact with gateways and brokers in a bi-directional\nway. Let's distinguish communications the following way:\n\n\n\n\nUplink communication (from a gateway to one or several brokers)\n\n\nDownlink communication (from a broker to a gateway)\n\n\n\n\nCommunications protocols used between, on the one hand, gateways and the router (uplink) and,\non the other hand, the router and brokers (downlink) don't have to be identical. \n\n\nBoth communication processes have their own characteristics and behavior, they will be detailed\nseparately. \n\n\nUplink communication\n\n\nA given gateway will be connected to a router of its choice, meaning that the gateway is\nconfigured to interact with that precise router (a gateway could be configured for several\nrouters, but the idea is the same; they are not allowed dynamically and won't change as long as\nthe configuration remains the same). Obviously, a router might received communications from\nseveral gateways as well. Thus, routers do not have upfront knowledge of gateways. A router\nonly receives incoming connections from gateways, and once these are closed, it keeps no trace\nof the gateway. A router is thereby a machine on which gateway will attempt to connect. This\nassumes that the router is accessible via a static IP address or solvable through a DNS\nservice. The whole protocol used by gateways can be found \nhere\n and could be\nsum up as follow:\n\n\n\n\nGateways initiate communication with a router\n\n\nGateways send data using a json structure and containing one or several packets\n\n\nThe router acknowledge reception of data\n\n\nGateways could be protected by a firewall or could use a NAT, routers cannot initiate communications\n\n\nGateways might trigger and pull the router periodically to keep a connection open (this is\n  fairly an implementation detail, but the gateway protocol we are refering to is describing an\n  implementation. We'll see how we handle this in the next section)\n\n\nThe communication is closed after a delay (after the second receive window, cf. downlink\n  communication)\n\n\n\n\nOnce a communication is established with a gateway and a packet received, the router has to\ndetermine to which broker should the packet be forwarded. Two options exist:\n\n\n\n\nThe address is known and associated to a broker\n\n\nThe address is unknown\n\n\n\n\nThe former option will lead to a direct forwarding whereas the latter will require a network\ndiscovering / broadcasting (see the section \nAddress resolution and caching\n).\n\n\nDownlink communication\n\n\nBecause of the first version, the network will only supports devices of class A, the connection\nbetween a gateway and a router would stay opened for a maximum of 2 seconds. The whole process\nis detailed in the \nLoRaWAN specifications 1.0\n - section 3.3 Receive Windows. In few\nwords though, after having emitted messages, a class A node will open two short receive windows\nand will allow incoming messages from a gateway. Windows are opened exactly one and two seconds\nafter the packet's emission. Sending packet at the right time is part of the gateway\nresponsibility, however, scheduling the emission is part of the network's one. \n\n\nIf any command or data have to be sent to the node, it has to be done precisely during one of\nthis two windows. More details about commands are given in the section related to the\nNetwork Server. Incidentally, only one of the two windows is available, meaning that sending\nthrough the first window will cause the second one to never be opened. \n\n\n\n\n\n\nReceive Windows\n\n\n\n\nHaving said that, a downlink communication could be initiated by either an Application or a\nNetwork Server in response of an uplink message from a device. The role of a router is to\nforward those messages, not to trigger or schedule them.\n\n\nAddress resolution and caching\n\n\nA router has a configured list of brokers addresses as well as a local cache associating device\nadresses to brokers. Entries of the cache get invalidated at regular interval (to determine\nduring testing or by computing), meaning that they are removed from the cache.\n\nWhen receiving a message, the router is in charge of looking into its local cache to determine\nwether or not a broker is known for the related node and segment. This is done by broadcasting a\nmessage to each known broker and by listening to their answers for the given message. \n\n\nThe router then stores each broker able to handle messages coming from the given node. However,\nbecause:\n\n\n\n\nHandlers may register after a node emits a signal to brokers\n\n\nA broker might not be available at the moment the broadcasting is done\n\n\nTwo node addresses are in collision\n\n\n\n\nThe cache has to be invalidated to allow the network to recover a consistent state. Such that\nno mapping between an address and a broker is settled forever after a first broadcast. However,\nwhen an address is known and is not invalidated, any issue listed above will remain until the\nnext invalidation. \n\n\nInterfaces\n\n\nIn order to communicate with the outside world, we'll split the router in three parts: \n\n\n\n\nThe core router\n\n\nAn uplink adapter\n\n\nA downlink adapter\n\n\n\n\nThe idea is to avoid to tightly couple the router core features with the way it is\ncommunicating. By doing such a separation of concerns, we allow the router to evolve and change\nits communication protocol at any moment, without any impact on the core mechanisms. Thus, as\nlong as the adapters remain compliant to a given interface they can be switched on demand. \n\n\nUplink adapter\n\n\nWe consider the following methods for the Uplink adapter (hereby known as \nUpAdapter\n):\n\n\n-- Notify the gateway that the given packet has been received\nack :: UpAdapter, Packet -\n Unit\n\n-- Send a downlink packet to a gateway\nforward :: UpAdapter, Packet -\n Unit\n\n\n\n\nThe uplink adapter is thereby in charge of queuing incoming packets, and trigger the router to\nhandle them properly. Because data coming from a gateway aren't formatted in the right way and\nalso because a gateway might send several packets through the same message, it is under the\nuplink adapter responsability to decode and interpret the data accordingly. \n\n\nDownlink adapter\n\n\nWe consider the following methods for the Downlink adapter (hereby known as \nDownAdapter\n):\n\n\n-- Send a packet to every available brokers. This method should trigger \n-- back some calls on the router to inform the router about which Broker \n-- are indeed responsible for the Packet.\nbroadcast :: DownAdapter, Packet -\n Unit\n\n-- Forward an uplink packet to a list of brokers using their addresses\nforward :: DownAdapter, BrokerAddr[], Packet -\n Unit\n\n\n\n\nThe downlink adapter should implement mechanism to handle network discovering (\nbroadcast\n).\nBasically, this will be done when there is no known broker for a given packet. The downlink\nadapter is thereby in charge of registering device addresses to the core router once brokers\nhave been discovered. \n\n\nCore\n\n\nThe core router (hereby known as \nRouter\n) handle all the router logic. It also supplies a\nconcise interface to allow both adapters to trigger actions. Any error or success from both\nadapters could trigger one of the following method.\n\n\n-- Ask the router to handle a specific error. \nhandleError :: Router, Error -\n Unit\n\n-- Handle an incoming uplink packet\nhandleUplink :: Router, Packet -\n Unit\n\n-- Handle an incoming downlink packet\nhandleDownlink :: Router, Packet -\n Unit\n\n-- Register a bunch of brokers address for a given device\nregisterDevice :: Router, DeviceAddr, BrokerAddr[] -\n Unit\n\n\n\n\nThe \nhandleError\n method gives adapters a way to notify the router of an unresolved transaction\nor an incorrect behavior from the network. Errors are detailed below and should be explicit\nenough to allow the router to recover from it. \n\n\nFlow Chart\n\n\n//TODO\n\n\nErrors\n\n\nErrors types the router may encounter are listed right below. This list isn't settled and is\nlikely to grow during the development. However, it gives an overview of referenced errors. By\nconvention, all error names are written in \nsnake_case\n.\n\n\n\n\n\n\n\n\nname\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\ninvalid_packet\n\n\nThe given packet has a bad format\n\n\n\n\n\n\nconnection_lost\n\n\nThe connection with a recipient has been lost\n\n\n\n\n\n\nno_response\n\n\nNo response received from a recipient\n\n\n\n\n\n\nunable_forward_up\n\n\nUnable to forward a packet (uplink)\n\n\n\n\n\n\nunable_forward_down\n\n\nUnable to forward a packet (downlink)", 
            "title": "Router"
        }, 
        {
            "location": "/router/#router", 
            "text": "R  Description      R-1  Forward uplink messages to brokers    R-2  Forward downlink messages to gateways        R-1  Description      R-1.1  Listen and receive incoming uplink transmissions    R-1.2  Decode an incoming transmission    R-1.3  Lookup a device address    R-1.4  Forward a packet to broker(s)        R-1.3  Description      R-1.3.1  Lookup local storage addresses    R-1.3.2  Invalidate expired entries        R-1.4  Description      R-1.4.1  Send a packet to known brokers    R-1.4.2  Broadcast a packet to all brokers    R-1.4.3  Store device address and associated broker(s)        R-2  Description      R-2.1  Listen and receive incoming downlink transmissions    R-2.2  Determine recipient gateway(s)    R-2.3  Forward a packet to gateway(s)", 
            "title": "Router"
        }, 
        {
            "location": "/router/#role", 
            "text": "The router's role is straightforward; It has to transfer packets coming from an emitter to the\nright recipient. The emitter and the recipient could be either:   A gateway and a broker  A broker and a gateway   This implies the router is able to interact with gateways and brokers in a bi-directional\nway. Let's distinguish communications the following way:   Uplink communication (from a gateway to one or several brokers)  Downlink communication (from a broker to a gateway)   Communications protocols used between, on the one hand, gateways and the router (uplink) and,\non the other hand, the router and brokers (downlink) don't have to be identical.   Both communication processes have their own characteristics and behavior, they will be detailed\nseparately.   Uplink communication  A given gateway will be connected to a router of its choice, meaning that the gateway is\nconfigured to interact with that precise router (a gateway could be configured for several\nrouters, but the idea is the same; they are not allowed dynamically and won't change as long as\nthe configuration remains the same). Obviously, a router might received communications from\nseveral gateways as well. Thus, routers do not have upfront knowledge of gateways. A router\nonly receives incoming connections from gateways, and once these are closed, it keeps no trace\nof the gateway. A router is thereby a machine on which gateway will attempt to connect. This\nassumes that the router is accessible via a static IP address or solvable through a DNS\nservice. The whole protocol used by gateways can be found  here  and could be\nsum up as follow:   Gateways initiate communication with a router  Gateways send data using a json structure and containing one or several packets  The router acknowledge reception of data  Gateways could be protected by a firewall or could use a NAT, routers cannot initiate communications  Gateways might trigger and pull the router periodically to keep a connection open (this is\n  fairly an implementation detail, but the gateway protocol we are refering to is describing an\n  implementation. We'll see how we handle this in the next section)  The communication is closed after a delay (after the second receive window, cf. downlink\n  communication)   Once a communication is established with a gateway and a packet received, the router has to\ndetermine to which broker should the packet be forwarded. Two options exist:   The address is known and associated to a broker  The address is unknown   The former option will lead to a direct forwarding whereas the latter will require a network\ndiscovering / broadcasting (see the section  Address resolution and caching ).  Downlink communication  Because of the first version, the network will only supports devices of class A, the connection\nbetween a gateway and a router would stay opened for a maximum of 2 seconds. The whole process\nis detailed in the  LoRaWAN specifications 1.0  - section 3.3 Receive Windows. In few\nwords though, after having emitted messages, a class A node will open two short receive windows\nand will allow incoming messages from a gateway. Windows are opened exactly one and two seconds\nafter the packet's emission. Sending packet at the right time is part of the gateway\nresponsibility, however, scheduling the emission is part of the network's one.   If any command or data have to be sent to the node, it has to be done precisely during one of\nthis two windows. More details about commands are given in the section related to the\nNetwork Server. Incidentally, only one of the two windows is available, meaning that sending\nthrough the first window will cause the second one to never be opened.     Receive Windows   Having said that, a downlink communication could be initiated by either an Application or a\nNetwork Server in response of an uplink message from a device. The role of a router is to\nforward those messages, not to trigger or schedule them.  Address resolution and caching  A router has a configured list of brokers addresses as well as a local cache associating device\nadresses to brokers. Entries of the cache get invalidated at regular interval (to determine\nduring testing or by computing), meaning that they are removed from the cache. \nWhen receiving a message, the router is in charge of looking into its local cache to determine\nwether or not a broker is known for the related node and segment. This is done by broadcasting a\nmessage to each known broker and by listening to their answers for the given message.   The router then stores each broker able to handle messages coming from the given node. However,\nbecause:   Handlers may register after a node emits a signal to brokers  A broker might not be available at the moment the broadcasting is done  Two node addresses are in collision   The cache has to be invalidated to allow the network to recover a consistent state. Such that\nno mapping between an address and a broker is settled forever after a first broadcast. However,\nwhen an address is known and is not invalidated, any issue listed above will remain until the\nnext invalidation.", 
            "title": "Role"
        }, 
        {
            "location": "/router/#interfaces", 
            "text": "In order to communicate with the outside world, we'll split the router in three parts:    The core router  An uplink adapter  A downlink adapter   The idea is to avoid to tightly couple the router core features with the way it is\ncommunicating. By doing such a separation of concerns, we allow the router to evolve and change\nits communication protocol at any moment, without any impact on the core mechanisms. Thus, as\nlong as the adapters remain compliant to a given interface they can be switched on demand.   Uplink adapter  We consider the following methods for the Uplink adapter (hereby known as  UpAdapter ):  -- Notify the gateway that the given packet has been received\nack :: UpAdapter, Packet -  Unit\n\n-- Send a downlink packet to a gateway\nforward :: UpAdapter, Packet -  Unit  The uplink adapter is thereby in charge of queuing incoming packets, and trigger the router to\nhandle them properly. Because data coming from a gateway aren't formatted in the right way and\nalso because a gateway might send several packets through the same message, it is under the\nuplink adapter responsability to decode and interpret the data accordingly.   Downlink adapter  We consider the following methods for the Downlink adapter (hereby known as  DownAdapter ):  -- Send a packet to every available brokers. This method should trigger \n-- back some calls on the router to inform the router about which Broker \n-- are indeed responsible for the Packet.\nbroadcast :: DownAdapter, Packet -  Unit\n\n-- Forward an uplink packet to a list of brokers using their addresses\nforward :: DownAdapter, BrokerAddr[], Packet -  Unit  The downlink adapter should implement mechanism to handle network discovering ( broadcast ).\nBasically, this will be done when there is no known broker for a given packet. The downlink\nadapter is thereby in charge of registering device addresses to the core router once brokers\nhave been discovered.   Core  The core router (hereby known as  Router ) handle all the router logic. It also supplies a\nconcise interface to allow both adapters to trigger actions. Any error or success from both\nadapters could trigger one of the following method.  -- Ask the router to handle a specific error. \nhandleError :: Router, Error -  Unit\n\n-- Handle an incoming uplink packet\nhandleUplink :: Router, Packet -  Unit\n\n-- Handle an incoming downlink packet\nhandleDownlink :: Router, Packet -  Unit\n\n-- Register a bunch of brokers address for a given device\nregisterDevice :: Router, DeviceAddr, BrokerAddr[] -  Unit  The  handleError  method gives adapters a way to notify the router of an unresolved transaction\nor an incorrect behavior from the network. Errors are detailed below and should be explicit\nenough to allow the router to recover from it.", 
            "title": "Interfaces"
        }, 
        {
            "location": "/router/#flow-chart", 
            "text": "//TODO", 
            "title": "Flow Chart"
        }, 
        {
            "location": "/router/#errors", 
            "text": "Errors types the router may encounter are listed right below. This list isn't settled and is\nlikely to grow during the development. However, it gives an overview of referenced errors. By\nconvention, all error names are written in  snake_case .     name  description      invalid_packet  The given packet has a bad format    connection_lost  The connection with a recipient has been lost    no_response  No response received from a recipient    unable_forward_up  Unable to forward a packet (uplink)    unable_forward_down  Unable to forward a packet (downlink)", 
            "title": "Errors"
        }, 
        {
            "location": "/broker/", 
            "text": "Broker\n\n\nRole\n\n\nBrokers constitute the heart of the network. They hold the logic that makes every other\ncomponent work together (routers, network servers and handlers). They play a role of mediator,\nmaking sure that packets are correct and handling communications between other components. To\neach broker is associated a given network server with which it is working closely. We can see\nthe network server as external ressources of computing and storage to which a broker could\nrefer at any time. \n\n\nTherefore, a broker is in charge of a set of nodes. This is a 1-to-1 relation meaning that a\nnode is controlled by a unique broker. There is for the moment no duplication or sharing\npossible. A broker does not have access to network servers different from the one it has been\nassigned. A node isn't shared and all packets coming from a given node end up in the same broker.\n\n\nBesides, a broker does not know any router in advance. The process is basically similar to the way\ngateways and routers discover each other. A router will initiate a communication\nwith a broker. After dealing with the communication, the broker may reply to the router and\nwill forget about its existence. Brokers are known from routers, like routers are\nknown from gateways. \n\n\nOn the other hand, brokers communicate with a bunch of handlers that have registered themselves\nbeforehand. This way, when a end-device joins the network every broker has to communicate with\nits own handlers list to determine whether or not it has to handle packets incoming from that\ndevice. The previous assertion assumes that a given handler isn't registered to several\nbrokers. \n\n\nDiscussion\n   \n\n\n\n\nWhat if a broker goes down? How can we ensure the reliability of the network?\n\n\n\n\nRelations are schematically represented in the next diagram. \n\n\n\n\n\n\nBroker's relations\n\n\n\n\nFor each node it is in charge of, the broker holds a network session key associated to the node.\nIt is thereby able to check the integrity of the packet by doing a \nMIC check\n. The process is\ndetailed in the \nLoRaWAN specifications\n - section 4.4 Message Integrity Code (MIC). \n\n\nDepending of the packet's nature, the broker might communicate with either its network server\nor a registered handler. Part of the packet's message contains a \nMAC header\n \nMHDR\n which is\nnot encrypted and gives details about the packet's nature (cf the \npayload\ncheatsheet\n). Thus, for any command (\nFPort\n set to \n0\n) the broker would\nforward the action to its network server. Otherwise, the packet is forwarded to the right\nhandler. \n\n\nUplink transmissions\n\n\nThe broker is waiting for router to forward packets coming from nodes. When receiving a packet,\nthe broker should firstly check whether or not it should take care of the packet. This is done\nby looking into a local storage of node addresses. This is list of addresses is created\ndynamically during the broker's lifecycle as long as handlers register to the broker. \nThen, because collisions may happen between node adresses, the broker also has to perform a\n\nMIC check\n to ensure both the validity and its responsibility for the given packet. \n\n\nAn unknown address or a invalid \nMIC check\n should lead to an error transmitted to the router\nemitter. Errors are detailed in a next section. If everything went well, the broker has to\ndecode the packet \nMAC header - MHDR\n and determine whether the packet carry a command or data.\nThe broker's behavior is thereby slightly different regarding to the packet's content. By the\nby, a packet may contain both a command and data, in such a case, it will be processed for both\ncontent. \n\n\nPacket with commands\n\n\n\n\nFor any received command, the broker will forward the packet to the network server able to\ndeal with the command. A command is completely invisible to the application (and thus,\nhandlers). By the by, when forwarding a command to a network server, the broker might wait\nfor an answer until a timeout delay is reached (after the second receive window is missed for\ninstance).\n\n\n\n\nPacket with data\n\n\n\n\nWhen the packet is carrying data towards an application, it should be forwarded to the right\nhandler. In a similar way of what is done with commands, the broker will also wait for an\nanswer to reply to the router.  In the meantime, a broker will notify its network server that\na receive window for the given device is available. The network server should either reply by\na command to send back, or deny the offer. \n\n\n\n\nJoin request\n\n\n\n\nA special edge-case requires an additional behavior. Join request might be sent from a\ndevice, in which case, the handler has to be contacted as a referee in order to authorize or\nreject the willing node. In case of success, the network server should be notified in order\nto setup and initialize the node managing in the future. \n\n\n\n\n\n\n\n\nBroker dispatching\n\n\n\n\nDownlink communication\n\n\nOnce all required tenants have replied, the broker has to merge the response into one single\npacket and send it back to the router (if necessary, it could happen that the request does not\nneed any packet to be sent as answer). \n\n\nInterfaces\n\n\nIn order to communicate with other components, a broker will be split in four parts:\n\n\n\n\nThe core broker\n\n\nThe router adapter\n\n\nThe handler adapter\n\n\nThe network server adapter\n\n\n\n\nThe idea is to avoid to tightly couple the broker core features with the way it is\ncommunicating. By doing such a separation of concerns, we allow the broker to evolve and change\nits communication protocols at any moment without any impact on the core mechanisms. Thus, as\nlong as the adapters remain compliant to a given interface, they can be switched on demand. \n\n\nWe previously identified the communication needs between the broker and other components.\nIncidentally, all adapters and the core broker are sharing a same packet structure (see\n\nCommon\n for more details).\n\n\nThe router adapter\n\n\nWe consider the following methods for the Router adapter (hereby known as \nRoutAdapter\n):\n\n\n-- Reject a packet previously received by the broker\nreject :: RoutAdapter, Packet -\n Unit\n\n-- Notify routers that the given packet has been received and is handled\nack :: RoutAdapter, Packet -\n Unit \n\n-- Send a packet as response to a router\nforward :: RoutAdapter, Packet -\n Unit\n\n\n\n\nThe handler adapter\n\n\nWe consider the following methods for the Handler adapter (hereby known as \nHandAdapter\n):\n\n\n--  Forward a join request to the handler\njoin :: HandAdapter, HandAddr, Packet -\n Unit \n\n-- Forward data to the handler\nforward :: HandAdapter, HandAddr, Packet -\n Unit\n\n\n\n\nThe network server adapter\n\n\nWe consider the following methods for the Network Server adapter (hereby known as \nNSAdapter\n):\n\n\n-- Forward a command to the Network Server. \ncommand :: NSAdapter, Packet -\n Command\n\n\n\n\nThe core broker\n\n\nWe consider the following methods for the Core Broker (hereby kown as \nBroker\n): \n\n\n-- Handle an error thrown by an adapter\nhandleError :: Broker, Error -\n Unit\n\n-- Handle an incoming packet from the router\nhandleUplink :: Broker, Packet -\n Unit\n\n-- Handle an incoming packet from the handler\nhandleData :: Broker, DevAddr, Data -\n Unit\n\n-- Handle an incoming command from the Network Server\nhandleCommand :: Broker, DevAddr, Command -\n Unit\n\n-- Receive and store a network session key associated to a device\nhandleNwkSKey :: Broker, DevAdrr, NwkSKey -\n Unit\n\n\n\n\n\nFlow Chart\n\n\n//TODO", 
            "title": "Broker"
        }, 
        {
            "location": "/broker/#broker", 
            "text": "", 
            "title": "Broker"
        }, 
        {
            "location": "/broker/#role", 
            "text": "Brokers constitute the heart of the network. They hold the logic that makes every other\ncomponent work together (routers, network servers and handlers). They play a role of mediator,\nmaking sure that packets are correct and handling communications between other components. To\neach broker is associated a given network server with which it is working closely. We can see\nthe network server as external ressources of computing and storage to which a broker could\nrefer at any time.   Therefore, a broker is in charge of a set of nodes. This is a 1-to-1 relation meaning that a\nnode is controlled by a unique broker. There is for the moment no duplication or sharing\npossible. A broker does not have access to network servers different from the one it has been\nassigned. A node isn't shared and all packets coming from a given node end up in the same broker.  Besides, a broker does not know any router in advance. The process is basically similar to the way\ngateways and routers discover each other. A router will initiate a communication\nwith a broker. After dealing with the communication, the broker may reply to the router and\nwill forget about its existence. Brokers are known from routers, like routers are\nknown from gateways.   On the other hand, brokers communicate with a bunch of handlers that have registered themselves\nbeforehand. This way, when a end-device joins the network every broker has to communicate with\nits own handlers list to determine whether or not it has to handle packets incoming from that\ndevice. The previous assertion assumes that a given handler isn't registered to several\nbrokers.   Discussion       What if a broker goes down? How can we ensure the reliability of the network?   Relations are schematically represented in the next diagram.     Broker's relations   For each node it is in charge of, the broker holds a network session key associated to the node.\nIt is thereby able to check the integrity of the packet by doing a  MIC check . The process is\ndetailed in the  LoRaWAN specifications  - section 4.4 Message Integrity Code (MIC).   Depending of the packet's nature, the broker might communicate with either its network server\nor a registered handler. Part of the packet's message contains a  MAC header   MHDR  which is\nnot encrypted and gives details about the packet's nature (cf the  payload\ncheatsheet ). Thus, for any command ( FPort  set to  0 ) the broker would\nforward the action to its network server. Otherwise, the packet is forwarded to the right\nhandler.   Uplink transmissions  The broker is waiting for router to forward packets coming from nodes. When receiving a packet,\nthe broker should firstly check whether or not it should take care of the packet. This is done\nby looking into a local storage of node addresses. This is list of addresses is created\ndynamically during the broker's lifecycle as long as handlers register to the broker. \nThen, because collisions may happen between node adresses, the broker also has to perform a MIC check  to ensure both the validity and its responsibility for the given packet.   An unknown address or a invalid  MIC check  should lead to an error transmitted to the router\nemitter. Errors are detailed in a next section. If everything went well, the broker has to\ndecode the packet  MAC header - MHDR  and determine whether the packet carry a command or data.\nThe broker's behavior is thereby slightly different regarding to the packet's content. By the\nby, a packet may contain both a command and data, in such a case, it will be processed for both\ncontent.   Packet with commands   For any received command, the broker will forward the packet to the network server able to\ndeal with the command. A command is completely invisible to the application (and thus,\nhandlers). By the by, when forwarding a command to a network server, the broker might wait\nfor an answer until a timeout delay is reached (after the second receive window is missed for\ninstance).   Packet with data   When the packet is carrying data towards an application, it should be forwarded to the right\nhandler. In a similar way of what is done with commands, the broker will also wait for an\nanswer to reply to the router.  In the meantime, a broker will notify its network server that\na receive window for the given device is available. The network server should either reply by\na command to send back, or deny the offer.    Join request   A special edge-case requires an additional behavior. Join request might be sent from a\ndevice, in which case, the handler has to be contacted as a referee in order to authorize or\nreject the willing node. In case of success, the network server should be notified in order\nto setup and initialize the node managing in the future.      Broker dispatching   Downlink communication  Once all required tenants have replied, the broker has to merge the response into one single\npacket and send it back to the router (if necessary, it could happen that the request does not\nneed any packet to be sent as answer).", 
            "title": "Role"
        }, 
        {
            "location": "/broker/#interfaces", 
            "text": "In order to communicate with other components, a broker will be split in four parts:   The core broker  The router adapter  The handler adapter  The network server adapter   The idea is to avoid to tightly couple the broker core features with the way it is\ncommunicating. By doing such a separation of concerns, we allow the broker to evolve and change\nits communication protocols at any moment without any impact on the core mechanisms. Thus, as\nlong as the adapters remain compliant to a given interface, they can be switched on demand.   We previously identified the communication needs between the broker and other components.\nIncidentally, all adapters and the core broker are sharing a same packet structure (see Common  for more details).  The router adapter  We consider the following methods for the Router adapter (hereby known as  RoutAdapter ):  -- Reject a packet previously received by the broker\nreject :: RoutAdapter, Packet -  Unit\n\n-- Notify routers that the given packet has been received and is handled\nack :: RoutAdapter, Packet -  Unit \n\n-- Send a packet as response to a router\nforward :: RoutAdapter, Packet -  Unit  The handler adapter  We consider the following methods for the Handler adapter (hereby known as  HandAdapter ):  --  Forward a join request to the handler\njoin :: HandAdapter, HandAddr, Packet -  Unit \n\n-- Forward data to the handler\nforward :: HandAdapter, HandAddr, Packet -  Unit  The network server adapter  We consider the following methods for the Network Server adapter (hereby known as  NSAdapter ):  -- Forward a command to the Network Server. \ncommand :: NSAdapter, Packet -  Command  The core broker  We consider the following methods for the Core Broker (hereby kown as  Broker ):   -- Handle an error thrown by an adapter\nhandleError :: Broker, Error -  Unit\n\n-- Handle an incoming packet from the router\nhandleUplink :: Broker, Packet -  Unit\n\n-- Handle an incoming packet from the handler\nhandleData :: Broker, DevAddr, Data -  Unit\n\n-- Handle an incoming command from the Network Server\nhandleCommand :: Broker, DevAddr, Command -  Unit\n\n-- Receive and store a network session key associated to a device\nhandleNwkSKey :: Broker, DevAdrr, NwkSKey -  Unit", 
            "title": "Interfaces"
        }, 
        {
            "location": "/broker/#flow-chart", 
            "text": "//TODO", 
            "title": "Flow Chart"
        }, 
        {
            "location": "/networkserver/", 
            "text": "Network Server\n\n\nRole\n\n\nA network server is a component dedicated to the network management. It handle the required\nlogic to handle and to emit MAC commands (more precisions about MAC commands are given below).\nBasically, a network server is composed of two parts:\n\n\n\n\na core logic\n\n\na data storage\n\n\n\n\nThe former interprets commands sent by nodes, forwarded by routers and brokers, combine them\nwith data stored in the latter in order to give an appropriate answer. The main usecase of the\nnetwork server will concern the adaptive data rate (\nADR\n) control detailed in the \nLoRaWAN\nspecifications 1.0\n - section 4.3.1.1 Adaptive data rate control in frame header. \n\n\nIn order to keep the network highly reactive, we'll adopt an in-memory storage. The network\nserver will make sure data are persisted regularly in order to both prevent from small\ndisruptions and recover from an existing state after an update or a maintainance activity.\n\n\nA network server is associated to a broker. The broker is forwarding, queuing and dispatching\npackets whereas the network server interprets them when necessary. Because a network server is\nonly having interactions with a dedicated broker, the set broker + network server could be\nseen as one unique component with a bigger but well-defined set of responsibilities. This\nalso implies that a given network server only has one and only one correspondent. There is no\ntransversal communication between network servers. The storage isn't distributed over the\nnetwork but rather fragmented over it. \n\n\ndiscussion\n   \n\n\n\n\nIn future versions, it could be nice for reliability to make data of network servers\naccessible from anywhere in the network. This nevertheless raises an issue about\nconfidentiality and confidence over all network constituents. \n\n\n\n\nBesides, the network server has also an active role during an over-the-air activation (join\nrequest) from a node: it allocates a new randomly generated device address. Because node\naddresses within the network are 24 bits length, there is 100% chances to allocate the same\naddress to two differents nodes after more or less 5500 allocations. However, all packets also\ncarry a MIC number, and thus there is still a way for the network to clearly identify a node\nwithout any risk of collision. \n\n\nMAC Commands\n\n\nThere is a set of fourteen (in fact, 7 commands and 7 acknowledgements) MAC commands that will\ntransit over the network and with which it should be compliant. A MAC command materialize an\nexchange between the network (via the network server) and the MAC layer of an env-device. This\nmeans that those commands are invisible for the application server registered to a handler, but\nalso for the one embedded on the device.\nThese commands serves the network internal management: \n\n\n\n\n\n\n\n\nCommand\n\n\nTransmitted by\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLinkCheckReq\n\n\nEnd-device\n\n\nUsed by an end-device to validate its connectivity to a network\n\n\n\n\n\n\nLinkCheckAns\n\n\nNetwork Server\n\n\nAnswer to LinkCheckReq command. Contains the received signal power estimation indicating to the end-device the quality of reception (link margin).\n\n\n\n\n\n\nLinkADRReq\n\n\nNetwork Server\n\n\nRequests the end-device to change data rate, transmit power, repetition rate or channel.\n\n\n\n\n\n\nLinkADRAns\n\n\nEnd-device\n\n\nAcknowledges the LinkADRReq\n\n\n\n\n\n\nDutyCycleReq\n\n\nNetwork Server\n\n\nSets the maximum aggregated transmit duty-cycle of a device\n\n\n\n\n\n\nDutyCycleAns\n\n\nEnd-device\n\n\nAcknowledges a DutyCycleReq command\n\n\n\n\n\n\nRXParamSetupReq\n\n\nNetwork Server\n\n\nSets the reception slots parameters\n\n\n\n\n\n\nRXParamSetupAns\n\n\nEnd-device\n\n\nAcknowledges a RXParamSetupReq command\n\n\n\n\n\n\nDevStatusReq\n\n\nNetwork Server\n\n\nRequest the status of the end-device\n\n\n\n\n\n\nDevStatusAns\n\n\nEnd-device\n\n\nReturns the status of the end-device, namely its battery level and its demodulation margin\n\n\n\n\n\n\nNewChannelReq\n\n\nNetwork Server\n\n\nCreates or modifies the definition of a radio channel\n\n\n\n\n\n\nNewChannelAns\n\n\nEnd-device\n\n\nAcknowledges a NewChannelReq command\n\n\n\n\n\n\nRXTimingSetupReq\n\n\nNetwork Server\n\n\nSets the timing of the reception slots\n\n\n\n\n\n\nRXTimingSetupAns\n\n\nEnd-device\n\n\nAcknowledges a RXTimingSetupReq command\n\n\n\n\n\n\n\n\nThe above table is extracted from the \nLoRaWAN specifications\n - Section 5 MAC Commands.\n\n\nTechnically, only one \"real\" command is emitted by the node, the rest is only acknowledgement\nand data transmission. Commands are mainly initiated by the network server and all of them are\ndetailed in the LoRaWan Specifications.\n\n\nCommunication with the broker\n\n\n// TODO", 
            "title": "Network Server"
        }, 
        {
            "location": "/networkserver/#network-server", 
            "text": "", 
            "title": "Network Server"
        }, 
        {
            "location": "/networkserver/#role", 
            "text": "A network server is a component dedicated to the network management. It handle the required\nlogic to handle and to emit MAC commands (more precisions about MAC commands are given below).\nBasically, a network server is composed of two parts:   a core logic  a data storage   The former interprets commands sent by nodes, forwarded by routers and brokers, combine them\nwith data stored in the latter in order to give an appropriate answer. The main usecase of the\nnetwork server will concern the adaptive data rate ( ADR ) control detailed in the  LoRaWAN\nspecifications 1.0  - section 4.3.1.1 Adaptive data rate control in frame header.   In order to keep the network highly reactive, we'll adopt an in-memory storage. The network\nserver will make sure data are persisted regularly in order to both prevent from small\ndisruptions and recover from an existing state after an update or a maintainance activity.  A network server is associated to a broker. The broker is forwarding, queuing and dispatching\npackets whereas the network server interprets them when necessary. Because a network server is\nonly having interactions with a dedicated broker, the set broker + network server could be\nseen as one unique component with a bigger but well-defined set of responsibilities. This\nalso implies that a given network server only has one and only one correspondent. There is no\ntransversal communication between network servers. The storage isn't distributed over the\nnetwork but rather fragmented over it.   discussion       In future versions, it could be nice for reliability to make data of network servers\naccessible from anywhere in the network. This nevertheless raises an issue about\nconfidentiality and confidence over all network constituents.    Besides, the network server has also an active role during an over-the-air activation (join\nrequest) from a node: it allocates a new randomly generated device address. Because node\naddresses within the network are 24 bits length, there is 100% chances to allocate the same\naddress to two differents nodes after more or less 5500 allocations. However, all packets also\ncarry a MIC number, and thus there is still a way for the network to clearly identify a node\nwithout any risk of collision.   MAC Commands  There is a set of fourteen (in fact, 7 commands and 7 acknowledgements) MAC commands that will\ntransit over the network and with which it should be compliant. A MAC command materialize an\nexchange between the network (via the network server) and the MAC layer of an env-device. This\nmeans that those commands are invisible for the application server registered to a handler, but\nalso for the one embedded on the device.\nThese commands serves the network internal management:      Command  Transmitted by  Description      LinkCheckReq  End-device  Used by an end-device to validate its connectivity to a network    LinkCheckAns  Network Server  Answer to LinkCheckReq command. Contains the received signal power estimation indicating to the end-device the quality of reception (link margin).    LinkADRReq  Network Server  Requests the end-device to change data rate, transmit power, repetition rate or channel.    LinkADRAns  End-device  Acknowledges the LinkADRReq    DutyCycleReq  Network Server  Sets the maximum aggregated transmit duty-cycle of a device    DutyCycleAns  End-device  Acknowledges a DutyCycleReq command    RXParamSetupReq  Network Server  Sets the reception slots parameters    RXParamSetupAns  End-device  Acknowledges a RXParamSetupReq command    DevStatusReq  Network Server  Request the status of the end-device    DevStatusAns  End-device  Returns the status of the end-device, namely its battery level and its demodulation margin    NewChannelReq  Network Server  Creates or modifies the definition of a radio channel    NewChannelAns  End-device  Acknowledges a NewChannelReq command    RXTimingSetupReq  Network Server  Sets the timing of the reception slots    RXTimingSetupAns  End-device  Acknowledges a RXTimingSetupReq command     The above table is extracted from the  LoRaWAN specifications  - Section 5 MAC Commands.  Technically, only one \"real\" command is emitted by the node, the rest is only acknowledgement\nand data transmission. Commands are mainly initiated by the network server and all of them are\ndetailed in the LoRaWan Specifications.  Communication with the broker  // TODO", 
            "title": "Role"
        }, 
        {
            "location": "/handler/", 
            "text": "Handler\n\n\nRole\n\n\nThe handler is the last buffer between the network and the app. Thus, it is in charge of doing\nanything private to the app. Handlers are a bunch of recurrent services that any app will need\nto interact with the network. Instead of having to implement all the mechanisms described\nbelow, applications can just trust a given handler to manipulate their secret keys and handle\nthe overhead logic of packet encryption, registration and decryption. \n\n\nThis raises nevertheless an important trust issue. The network is open, meaning that anyone can\njoin it and contribute with their own servers. The code is thereby accessible such that it\nsimplifies the installation of a component. However, The Things Network isn't a certificate\nauthority of any kind, meaning that we cannot ensure that a given broker implement a code\nstrictly identical to the one provided by the foundation. The question is still open and\ndiscussion are welcomed. \n\n\nAlso, for the rest of this document, we'll described handlers as a completely independant\ncomponent that interacts with both a broker and an application. In practice, handlers could be\npartially merged with an application or be provided as a cloud service. This does not change\nanything for the network point of view as long as handlers remain compliant with the uplink\ninterface detailed below. The following proposal states one kind of handler provided in the\nfirst version of the network. Different implementations with different mechanisms could exist,\nhowever, this document only refers to one type. \n\n\nHaving said that, the handler is supposed to perform the following actions:\n\n\n\n\nRegister an application and a bunch of personnalized devices and DevEUI\n\n\nRegister to a broker (with an application EUIs, \n\n\nReceive and decrypt incoming packets from a broker with deduplication mechanisms\n\n\nHandle join request (generate NwkSKey, AppSKey, AppNounce...)\n\n\nForward packet's payload to its application\n\n\nForward response from applications to brokers\n\n\n\n\nAgain, this components act as a relay between some recipients. Let's detail in the\ncommunication in two parts and distinguish uplink communication from application requests. We\nwon't talk about downlink communication because the handler materalize the end of the chain\nand, the downlink communication is part of the uplink process for the handler point of view.\nThe handler is managing the communication back and forth between the network and the\napplication. However, the application can still operate on a configuration level with the\nbroker (so far, only to register / unregister itself). \n\n\nHandler configuration\n\n\nIntially, the network is completely unaware of any application meaning that any messages\nemitted by gateways won't go further than routers. However, at any time, an application can\nconnect the network by interacting with a handler. \n\n\nTo join the network, the application has to provide several private data such as:\n\n\n\n\nAn application id\n\n\nA secret application key\n\n\nA list of known DevEUI \n\n\nWay back information (protocol + server)\n\n\n\n\nWith those pieces of information, the handler would be in charge of all the trafic towards the\ngiven application. An application could possibly updates the list of nodes or the communication\nprotocol later. \n\n\nThere is no reason for a handler to reject an application join request for the moment however,\nthe handler will still reply with a positive response to the willing application. \n\n\nUplink communication\n\n\nWe'll call uplink communication any communication coming from brokers. Uplink communications\ncould be either data coming from a node or a join request.  \n\n\nBecause of the network architecture, several duplicates of the same messages could arrive to\nthe handler. We assume that all of those messages are arriving all in the same time. The\nhandler will then have to deduplicate all messages if necessary and proceed to a geolocation\nbased on the information provided by the gateways. The handler also has an access to the\napplication secret key, Thus, it could decrypt the data and forward them to the application.", 
            "title": "Handler"
        }, 
        {
            "location": "/handler/#handler", 
            "text": "", 
            "title": "Handler"
        }, 
        {
            "location": "/handler/#role", 
            "text": "The handler is the last buffer between the network and the app. Thus, it is in charge of doing\nanything private to the app. Handlers are a bunch of recurrent services that any app will need\nto interact with the network. Instead of having to implement all the mechanisms described\nbelow, applications can just trust a given handler to manipulate their secret keys and handle\nthe overhead logic of packet encryption, registration and decryption.   This raises nevertheless an important trust issue. The network is open, meaning that anyone can\njoin it and contribute with their own servers. The code is thereby accessible such that it\nsimplifies the installation of a component. However, The Things Network isn't a certificate\nauthority of any kind, meaning that we cannot ensure that a given broker implement a code\nstrictly identical to the one provided by the foundation. The question is still open and\ndiscussion are welcomed.   Also, for the rest of this document, we'll described handlers as a completely independant\ncomponent that interacts with both a broker and an application. In practice, handlers could be\npartially merged with an application or be provided as a cloud service. This does not change\nanything for the network point of view as long as handlers remain compliant with the uplink\ninterface detailed below. The following proposal states one kind of handler provided in the\nfirst version of the network. Different implementations with different mechanisms could exist,\nhowever, this document only refers to one type.   Having said that, the handler is supposed to perform the following actions:   Register an application and a bunch of personnalized devices and DevEUI  Register to a broker (with an application EUIs,   Receive and decrypt incoming packets from a broker with deduplication mechanisms  Handle join request (generate NwkSKey, AppSKey, AppNounce...)  Forward packet's payload to its application  Forward response from applications to brokers   Again, this components act as a relay between some recipients. Let's detail in the\ncommunication in two parts and distinguish uplink communication from application requests. We\nwon't talk about downlink communication because the handler materalize the end of the chain\nand, the downlink communication is part of the uplink process for the handler point of view.\nThe handler is managing the communication back and forth between the network and the\napplication. However, the application can still operate on a configuration level with the\nbroker (so far, only to register / unregister itself).   Handler configuration  Intially, the network is completely unaware of any application meaning that any messages\nemitted by gateways won't go further than routers. However, at any time, an application can\nconnect the network by interacting with a handler.   To join the network, the application has to provide several private data such as:   An application id  A secret application key  A list of known DevEUI   Way back information (protocol + server)   With those pieces of information, the handler would be in charge of all the trafic towards the\ngiven application. An application could possibly updates the list of nodes or the communication\nprotocol later.   There is no reason for a handler to reject an application join request for the moment however,\nthe handler will still reply with a positive response to the willing application.   Uplink communication  We'll call uplink communication any communication coming from brokers. Uplink communications\ncould be either data coming from a node or a join request.    Because of the network architecture, several duplicates of the same messages could arrive to\nthe handler. We assume that all of those messages are arriving all in the same time. The\nhandler will then have to deduplicate all messages if necessary and proceed to a geolocation\nbased on the information provided by the gateways. The handler also has an access to the\napplication secret key, Thus, it could decrypt the data and forward them to the application.", 
            "title": "Role"
        }
    ]
}