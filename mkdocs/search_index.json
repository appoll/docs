{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\nForeword\n\n\nThis document hereby refers to the content of the whole website. Any contributor is welcomed\nand could give a hand in several manners:\n\n\n\n\nLooking for and correcting typos\n\n\nAdd relevant and non redundant information\n\n\nComplete a part marked as //TODO\n\n\n\n\nRegardless of what you'll attempt, make sure to check \nthe issues list on\nGitHub\n before doing anything\n. Thus, if nobody is already working on something\nrelated, open an issue with a clear and concise title and briefly explain your incoming changes\nin the description. Then, fork the project, do your work, and create a Pull Request on the\noriginal repository. \n\n\nTo sum up:\n\n\n\n\nCheck \nGitHub issues\n\n\nOpen a new issue if no one exist\n\n\nFork the repository\n\n\nCreate a Pull Request once you're done\n\n\n\n\nThanks a lot !\n\n\nComponents\n\n\nThe following document describe the specifications for The Things Network's Architecture\nversion 1. These specifications focus on the network architecture which includes 4 kinds of\ncomponents:\n\n\n\n\nRouters \n\n\nBrokers\n\n\nNetwork Servers\n\n\nHandlers\n\n\n\n\nIncidentally, those components are interacting with other external entities on which we have -\nif any - only few controls:\n\n\n\n\nNodes (also known as end-devices)\n\n\nGateways\n\n\nApplications\n\n\n\n\n\n\n\n\nNetwork components\n\n\n\n\nNode\n\n\nNodes or end-devices refer to one end of the chain. Devices emit signals using\n\nLoRa\n modulation and frequency range towards Gateways. They are split into\n3 classes: \n\n\n\n\nA\n: Cannot receive any data from the network unless they've initiated the communication\n\n\nB\n: Can receive data from the network at precisely scheduled windows (Beacons)\n\n\nC\n: Can receive data at any time from the network\n\n\n\n\nIncidentally, class A requires less power than B which requires less power than C. \nAn end-device has an address either assigned by the Network or self-defined. An end-device\nalso has a specific secret application session key and a network session key \n\n\nThese specifications primarly focus on the class A. Future network versions will implement\nmechanisms to handle class B and class C but they are irrevelant with the current document.\n\n\nGateway\n\n\nGateways might be seen as a way to transform multiple messages emitters into one much more\ndemanding emitter. Therefore, a Gateway gathers \nLoRa\n signals coming from a\nbunch of near end-devices. A given device does not need to know the nearest gateways, nor it\nhas to communicate with a specific one - signals are simply broadcasted into the wild open. \n\n\nGateways receive signals which reach them, and forward the message to a dedicated Router. The\nData could be either a sensor result or a specific network command such as a connection\nrequest. A Gateway actually send incoming packets to a router after having wrapped each of them\ninto a \njson\n structure holding meta-data about the Gateway itself (such as Gateway's\nidentifier, a timestamp and GPS coordinates if available).\n\n\nGateways can also emit packets coming from the network toward a Node using the \nLoRa\ntechnology\n. In fact, Gateways are in charge of taking care of emission at a\nscheduled time defined by the network meaning that the network is able to send packets to\nGateways at any moment, regardless of their emission time (see more about the two-windows\nresponse mechanism //TODO add a link). \n\n\nApplication\n\n\nRouter\n\n\nRouters are entry points of the network from Nodes perspective. A Router receives packets\ngathered by some Gateways and initially transmitted by Nodes. Then, it forwards those packets\nto one or several Brokers. The communication is seemingly bi-directional: Routers may also\ntransfer packets from Broker to Gateways. \n\n\n\n\n\n\nUplink forwarding\n\n\n\n\nBroker\n\n\nBrokers have a global vision of a network's part. They are in charge of several nodes, meaning\nthat they will handle packets coming from those nodes (thereby, they are able to tell to\nRouters if they can handle a given packet). Several Routers may send packets coming from the\nsame end-device (shared by several segments / Gateways), all duplicates are managed by the\nBroker and are sent to a corresponding Handler.\n\n\nA Broker is thereby able to check the integrity of a packet and is closely communicating with a\nNetwork Server in order to administrate the related device. As an order of magnitude, Brokers\nare designed to be in charge of a whole country or region (if the region has enough activity to\ndeserve a dedicated Broker).\n\n\nNetwork Server\n\n\nNetwork servers are processing \nMAC\n commands emitted by end-devices as well as taking care\nof the data rates and the frequency of the devices. Network Servers would emit commands to\noptimize the network by adjusting end-devices data rates / frequencies unless the node is\nrequesting to keep its configuration as is. \n\n\nFor the moment, a single Network Server will be associated for each Broker. No communication\nmechanisms between Network Servers is planned for the first version. Also, it won't be possible\nfor a Broker to query another Network Server than the one it has been assigned to. Those\nfeatures might be part of a second version. \n\n\nHandler\n\n\nHandlers materialize the entry point to the network for client Applications. They are secure\nreferees which encode and decode data coming from application before transmitting them to a\nBroker of the network. Therefore, they are in charge of handling applications secret keys and\nonly communicate an application id to Brokers (as well as a specific network session key,\ndescribed in further sections). This way, the whole chain is able to forward a packet to the\ncorresponding Handler without having any information about either the recipient (but a\nmeaningless id) or the content. \n\n\nBecause a given Handler is able to decrypt the data payload of a given packet, it could\nalso implement mechanisms such as Geolocation and send to the corresponding application some\ninteresting meta-data.\n\n\nA Handler could be either part of an application or a standalone trusty server on which\napplication may register. The Things Network will provide Handlers as part of the whole network\nbut - and this is true for any component - anyone could create its own implementation as long\nas it is compliant to the following specifications.\n\n\n\n\n\n\nUplink to an Application", 
            "title": "Overview"
        }, 
        {
            "location": "/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/#foreword", 
            "text": "This document hereby refers to the content of the whole website. Any contributor is welcomed\nand could give a hand in several manners:   Looking for and correcting typos  Add relevant and non redundant information  Complete a part marked as //TODO   Regardless of what you'll attempt, make sure to check  the issues list on\nGitHub  before doing anything . Thus, if nobody is already working on something\nrelated, open an issue with a clear and concise title and briefly explain your incoming changes\nin the description. Then, fork the project, do your work, and create a Pull Request on the\noriginal repository.   To sum up:   Check  GitHub issues  Open a new issue if no one exist  Fork the repository  Create a Pull Request once you're done   Thanks a lot !", 
            "title": "Foreword"
        }, 
        {
            "location": "/#components", 
            "text": "The following document describe the specifications for The Things Network's Architecture\nversion 1. These specifications focus on the network architecture which includes 4 kinds of\ncomponents:   Routers   Brokers  Network Servers  Handlers   Incidentally, those components are interacting with other external entities on which we have -\nif any - only few controls:   Nodes (also known as end-devices)  Gateways  Applications     Network components", 
            "title": "Components"
        }, 
        {
            "location": "/#node", 
            "text": "Nodes or end-devices refer to one end of the chain. Devices emit signals using LoRa  modulation and frequency range towards Gateways. They are split into\n3 classes:    A : Cannot receive any data from the network unless they've initiated the communication  B : Can receive data from the network at precisely scheduled windows (Beacons)  C : Can receive data at any time from the network   Incidentally, class A requires less power than B which requires less power than C. \nAn end-device has an address either assigned by the Network or self-defined. An end-device\nalso has a specific secret application session key and a network session key   These specifications primarly focus on the class A. Future network versions will implement\nmechanisms to handle class B and class C but they are irrevelant with the current document.", 
            "title": "Node"
        }, 
        {
            "location": "/#gateway", 
            "text": "Gateways might be seen as a way to transform multiple messages emitters into one much more\ndemanding emitter. Therefore, a Gateway gathers  LoRa  signals coming from a\nbunch of near end-devices. A given device does not need to know the nearest gateways, nor it\nhas to communicate with a specific one - signals are simply broadcasted into the wild open.   Gateways receive signals which reach them, and forward the message to a dedicated Router. The\nData could be either a sensor result or a specific network command such as a connection\nrequest. A Gateway actually send incoming packets to a router after having wrapped each of them\ninto a  json  structure holding meta-data about the Gateway itself (such as Gateway's\nidentifier, a timestamp and GPS coordinates if available).  Gateways can also emit packets coming from the network toward a Node using the  LoRa\ntechnology . In fact, Gateways are in charge of taking care of emission at a\nscheduled time defined by the network meaning that the network is able to send packets to\nGateways at any moment, regardless of their emission time (see more about the two-windows\nresponse mechanism //TODO add a link).", 
            "title": "Gateway"
        }, 
        {
            "location": "/#application", 
            "text": "", 
            "title": "Application"
        }, 
        {
            "location": "/#router", 
            "text": "Routers are entry points of the network from Nodes perspective. A Router receives packets\ngathered by some Gateways and initially transmitted by Nodes. Then, it forwards those packets\nto one or several Brokers. The communication is seemingly bi-directional: Routers may also\ntransfer packets from Broker to Gateways.     Uplink forwarding", 
            "title": "Router"
        }, 
        {
            "location": "/#broker", 
            "text": "Brokers have a global vision of a network's part. They are in charge of several nodes, meaning\nthat they will handle packets coming from those nodes (thereby, they are able to tell to\nRouters if they can handle a given packet). Several Routers may send packets coming from the\nsame end-device (shared by several segments / Gateways), all duplicates are managed by the\nBroker and are sent to a corresponding Handler.  A Broker is thereby able to check the integrity of a packet and is closely communicating with a\nNetwork Server in order to administrate the related device. As an order of magnitude, Brokers\nare designed to be in charge of a whole country or region (if the region has enough activity to\ndeserve a dedicated Broker).", 
            "title": "Broker"
        }, 
        {
            "location": "/#network-server", 
            "text": "Network servers are processing  MAC  commands emitted by end-devices as well as taking care\nof the data rates and the frequency of the devices. Network Servers would emit commands to\noptimize the network by adjusting end-devices data rates / frequencies unless the node is\nrequesting to keep its configuration as is.   For the moment, a single Network Server will be associated for each Broker. No communication\nmechanisms between Network Servers is planned for the first version. Also, it won't be possible\nfor a Broker to query another Network Server than the one it has been assigned to. Those\nfeatures might be part of a second version.", 
            "title": "Network Server"
        }, 
        {
            "location": "/#handler", 
            "text": "Handlers materialize the entry point to the network for client Applications. They are secure\nreferees which encode and decode data coming from application before transmitting them to a\nBroker of the network. Therefore, they are in charge of handling applications secret keys and\nonly communicate an application id to Brokers (as well as a specific network session key,\ndescribed in further sections). This way, the whole chain is able to forward a packet to the\ncorresponding Handler without having any information about either the recipient (but a\nmeaningless id) or the content.   Because a given Handler is able to decrypt the data payload of a given packet, it could\nalso implement mechanisms such as Geolocation and send to the corresponding application some\ninteresting meta-data.  A Handler could be either part of an application or a standalone trusty server on which\napplication may register. The Things Network will provide Handlers as part of the whole network\nbut - and this is true for any component - anyone could create its own implementation as long\nas it is compliant to the following specifications.    Uplink to an Application", 
            "title": "Handler"
        }, 
        {
            "location": "/router/", 
            "text": "Router\n\n\n\n\n\n\n\n\nR\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nR-1\n\n\nForward uplink messages to brokers\n\n\n\n\n\n\nR-2\n\n\nForward downlink messages to gateways\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR-1\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nR-1.1\n\n\nListen and receive incoming uplink transmissions\n\n\n\n\n\n\nR-1.2\n\n\nDecode an incoming transmission\n\n\n\n\n\n\nR-1.3\n\n\nLookup a device address\n\n\n\n\n\n\nR-1.4\n\n\nForward a packet to broker(s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR-1.3\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nR-1.3.1\n\n\nLookup local storage addresses\n\n\n\n\n\n\nR-1.3.2\n\n\nInvalidate expired entries\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR-1.4\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nR-1.4.1\n\n\nSend a packet to known brokers\n\n\n\n\n\n\nR-1.4.2\n\n\nBroadcast a packet to all brokers\n\n\n\n\n\n\nR-1.4.3\n\n\nStore device address and associated broker(s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR-2\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nR-2.1\n\n\nListen and receive incoming downlink transmissions\n\n\n\n\n\n\nR-2.2\n\n\nDetermine recipient gateway(s)\n\n\n\n\n\n\nR-2.3\n\n\nForward a packet to gateway(s)\n\n\n\n\n\n\n\n\nRole\n\n\nThe router's role is straightforward; It has to transfer packets coming from an emitter to the\nright recipient. The emitter and the recipient could be either:\n\n\n\n\nA gateway and a broker\n\n\nA broker and a gateway\n\n\n\n\nThis implies the router is able to interact with gateways and brokers in a bi-directional\nway. Let's distinguish communications the following way:\n\n\n\n\nUplink communication (from a gateway to one or several brokers)\n\n\nDownlink communication (from a broker to a gateway)\n\n\n\n\nCommunications protocols used between, on the one hand, gateways and the router (uplink) and,\non the other hand, the router and brokers (downlink) don't have to be identical. \n\n\nBoth communication processes have their own characteristics and behavior, they will be detailed\nseparately. \n\n\nUplink communication\n\n\nA given gateway will be connected to a router of its choice, meaning that the gateway is\nconfigured to interact with that precise router (a gateway could be configured for several\nrouters, but the idea is the same; they are not allowed dynamically and won't change as long as\nthe configuration remains the same). Obviously, a router might received communications from\nseveral gateways as well. Thus, gateways are completely unknown from a router - and would\nremain unknown during the router lifecycle.\n\n\nA router is thereby a machine on which gateway will attempt to connect. This assumes that the\nrouter is accessible via a static IP address or solvable through a DNS service. The whole\nprotocol used by gateways can be found \nhere\n and could be sum up as follow:\n\n\n\n\nGateways initiate communication with a router\n\n\nGateways send data using a json structure and containing one or several packets\n\n\nThe router acknowledge reception of data\n\n\nGateways could be protected by a firewall or could use a NAT, routers cannot initiate communications\n\n\nGateways might trigger and pull the router periodically to keep a connexion open (this is\n  fairly an implementation detail, but the gateway protocol we are refering to is describing an\n  implementation. We'll see how we handle this in the next section)\n\n\nThe communication is closed after a delay (after the second receive window, cf. downlink\n  communication)\n\n\n\n\nOnce a communication is established with a gateway and a packet received, the router has to\ndetermine to which broker should the packet be forwarded. Two options exist:\n\n\n\n\nThe address is known and associated to a broker\n\n\nThe address is unknown\n\n\n\n\nThe former option will lead to a direct forwarding whereas the latter will require a network\ndiscovering / broadcasting (see the section \nAddress resolution and caching\n).\n\n\nDownlink communication\n\n\nBecause of the first version, the network will only supports devices of class A, the connexion\nbetween a gateway and a router would stay opened for a maximum of 2 seconds. The whole process\nis detailed in the \nLoRaWAN specifications 1.0\n - section 3.3 Receive Windows. In few\nwords though, after having emitted messages, a class A node will open two short receive windows\nand will allow incoming messages from a gateway. Windows are opened exactly one and two seconds\nafter the packet's emission. Sending packet at the right time is part of the gateway\nresponsibility, however, scheduling the emission is part of the network's one. \n\n\nIf any command or data have to be sent to the node, it has to be done precisely during one of\nthis two windows. More details about commands are given in the section related to the\nNetwork Server. Incidentally, only one of the two windows is available, meaning that sending\nthrough the first window will cause the second one to never be opened. \n\n\n\n\n\n\nReceive Windows\n\n\n\n\nHaving said that, a downlink communication could be initiated by either an Application or a\nNetwork Server in response of an uplink message from a device. The role of a router is to\nforward those messages, not to trigger or schedule them.\n\n\nAddress resolution and caching\n\n\nA router has a configured list of brokers addresses as well as a local cache associating device\nadresses to brokers. Entries of the cache get invalidated at regular interval (to determine\nduring testing or by computing), meaning that they are removed from the cache.\n\nWhen receiving a message, the router is in charge of looking into its local cache to determine\nwether or not a broker is known for the related node and segment. This is done by broadcasting a\nmessage to each known broker and by listening to their answers for the given message. \n\n\nThe router then stores each broker able to handle messages coming from the given node. However,\nbecause:\n\n\n\n\nHandlers may register after a node emits a signal to brokers\n\n\nA broker might not be available at the moment the broadcasting is done\n\n\nTwo node addresses are in collision\n\n\n\n\nThe cache has to be invalidated to allow the network to recover a consistent state. Such that\nno mapping between an address and a broker is settled forever after a first broadcast. However,\nwhen an address is known and is not invalidated, any issue listed above will remain until the\nnext invalidation. \n\n\nDecoupling\n\n\nIn order to communicate with the outside world, we'll split the router in three parts: \n\n\n\n\nThe core router\n\n\nAn uplink adapter\n\n\nA downlink adapter\n\n\n\n\nThe idea is to avoid to tightly couple the router core features with the way it is\ncommunicating. By doing such a separation of concerns, we allow the router to evolve and change\nits communication protocol at any moment, without any impact on the core mechanisms. Thus, as\nlong as the adapters remain compliant to a given interface they can be switched on demand. \n\n\nAll three components will share a common representation of a packet tagged with a version\nnumber. As long as all component use compatible representation of a packet, they sould be able\nto communicate. \n\n\nPackets are \njson\n structure with the following structure:\n\n\n{\n    \ntime\n: \nString\n,\n    \ntmst\n: \nNumber\n,\n    \nfreq\n: \nNumber\n,\n    \nchan\n: \nNumber\n,\n    \nrfch\n: \nNumber\n,\n    \nstat\n: \nNumber\n,\n    \nmodu\n: \nString\n,\n    \ndatr\n: \nNumber\n, // In case of GFSK modulation\n    \ndatr\n: \nString\n, // In case of LoRa modulation\n    \ncodr\n: \nString\n,\n    \nrssi\n: \nNumber\n,\n    \nlsnr\n: \nNumber\n,\n    \nsize\n: \nNumber\n,\n    \ndata\n: \nString\n\n}\n\n\n\n\nMore information about the meaning of those fields could be found in the \nsemtech protocol\ndescription\n.\n\n\nUplink adapter\n\n\nWe consider the following methods for the Uplink adapter (hereby known as \nUpAdapter\n):\n\n\n-- Notify the gateway that the given packet has been received\nack :: UpAdapter, Packet -\n Unit\nack (adapter, packet)\n\n-- Send a downlink packet to a gateway\nforward :: UpAdapter, Packet -\n Unit\nforward (adapter, packet)\n\n\n\n\nThe uplink adapter is thereby in charge of queuing incoming packets, and trigger the router to\nhandle them properly. Because data coming from a gateway aren't formatted in the right way and\nalso because a gateway might send several packets through the same message, it is under the\nuplink adapter responsability to decode and interpret the data accordingly. \n\n\nDownlink adapter\n\n\nWe consider the following methods for the Downlink adapter (hereby known as \nDownAdapter\n):\n\n\n-- Send a packet to every available brokers. This method should trigger \n-- back some calls on the router to inform the router about which Broker \n-- are indeed responsible for the Packet.\nbroadcast :: DownAdapter, Packet -\n Unit\nbroadcast (adapter, packet)\n\n-- Forward an uplink packet to a list of brokers using their addresses\nforward :: DownAdapter, BrokerAddr[], Packet -\n Unit\nforward (adapter, [broAddr1, broAddr2], packet)\n\n\n\n\nThe downlink adapter should implement mechanism to handle network discovering (\nbroadcast\n).\nBasically, this will be done when there is no known broker for a given packet. The downlink\nadapter is thereby in charge of registering device addresses to the core router once brokers\nhave been discovered. \n\n\nCore\n\n\nThe core router (hereby known as \nRouter\n) handle all the router logic. It also supplies a\nconcise interface to allow both adapters to trigger actions. Any error or success from both\nadapters could trigger one of the following method.\n\n\n-- Ask the router to handle a specific error. \nhandleError :: Router, Error -\n Unit\nhandleError (router, err)\n\n-- Handle an incoming uplink packet\nhandleUplink :: Router, Packet -\n Unit\nhandleUplink (router, packet)\n\n-- Handle an incoming downlink packet\nhandleDownlink :: Router, Packet -\n Unit\nhandleDownlink (router, packet)\n\n-- Register a bunch of brokers address for a given device\nregisterDevice :: Router, DeviceAddr, BrokerAddr[] -\n Unit\nregisterDevice (router, devAddr, [broAddr1, broAddr2])\n\n\n\n\nThe \nhandleError\n method gives adapters a way to notify the router of an unresolved transaction\nor an incorrect behavior from the network. Errors are detailed below and should be explicit\nenough to allow the router to recover from it. \n\n\nErrors\n\n\nAny error coming from any router's components should provide the following information:\n\n\n\n\na name / identifier \n\n\na date (the moment it happens)\n\n\na message / description\n\n\nthe packet or data manipulated if any\n\n\n\n\nA given error will thus provide methods that reflect those attributes:\n\n\n-- Retrieve the error's name\nname :: Error -\n String\nname (err)\n\n-- Retrieve the error's creation date\ndate :: Error -\n Date|String\ndate (err) \n\n-- Retrieve the error's message\nmessage :: Error -\n String\nmessage (err)\n\n-- Retrieve the error's data\nparams :: Error -\n a\nparams (err)\n\n\n\n\nErrors types the router may encounter are listed right below. This list isn't settled and is\nlikely to grow during the development. However, it gives an overview of referenced errors. By\nconvention, all error names are written in \nsnake_case\n.\n\n\n\n\n\n\n\n\nname\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\ninvalid_packet\n\n\nThe given packet has a bad format\n\n\n\n\n\n\nconnection_lost\n\n\nThe connection with a recipient has been lost\n\n\n\n\n\n\nno_response\n\n\nNo response received from a recipient\n\n\n\n\n\n\nunable_forward_up\n\n\nUnable to forward a packet (uplink)\n\n\n\n\n\n\nunable_forward_down\n\n\nUnable to forward a packet (downlink)", 
            "title": "Router"
        }, 
        {
            "location": "/router/#router", 
            "text": "R  Description      R-1  Forward uplink messages to brokers    R-2  Forward downlink messages to gateways        R-1  Description      R-1.1  Listen and receive incoming uplink transmissions    R-1.2  Decode an incoming transmission    R-1.3  Lookup a device address    R-1.4  Forward a packet to broker(s)        R-1.3  Description      R-1.3.1  Lookup local storage addresses    R-1.3.2  Invalidate expired entries        R-1.4  Description      R-1.4.1  Send a packet to known brokers    R-1.4.2  Broadcast a packet to all brokers    R-1.4.3  Store device address and associated broker(s)        R-2  Description      R-2.1  Listen and receive incoming downlink transmissions    R-2.2  Determine recipient gateway(s)    R-2.3  Forward a packet to gateway(s)", 
            "title": "Router"
        }, 
        {
            "location": "/router/#role", 
            "text": "The router's role is straightforward; It has to transfer packets coming from an emitter to the\nright recipient. The emitter and the recipient could be either:   A gateway and a broker  A broker and a gateway   This implies the router is able to interact with gateways and brokers in a bi-directional\nway. Let's distinguish communications the following way:   Uplink communication (from a gateway to one or several brokers)  Downlink communication (from a broker to a gateway)   Communications protocols used between, on the one hand, gateways and the router (uplink) and,\non the other hand, the router and brokers (downlink) don't have to be identical.   Both communication processes have their own characteristics and behavior, they will be detailed\nseparately.   Uplink communication  A given gateway will be connected to a router of its choice, meaning that the gateway is\nconfigured to interact with that precise router (a gateway could be configured for several\nrouters, but the idea is the same; they are not allowed dynamically and won't change as long as\nthe configuration remains the same). Obviously, a router might received communications from\nseveral gateways as well. Thus, gateways are completely unknown from a router - and would\nremain unknown during the router lifecycle.  A router is thereby a machine on which gateway will attempt to connect. This assumes that the\nrouter is accessible via a static IP address or solvable through a DNS service. The whole\nprotocol used by gateways can be found  here  and could be sum up as follow:   Gateways initiate communication with a router  Gateways send data using a json structure and containing one or several packets  The router acknowledge reception of data  Gateways could be protected by a firewall or could use a NAT, routers cannot initiate communications  Gateways might trigger and pull the router periodically to keep a connexion open (this is\n  fairly an implementation detail, but the gateway protocol we are refering to is describing an\n  implementation. We'll see how we handle this in the next section)  The communication is closed after a delay (after the second receive window, cf. downlink\n  communication)   Once a communication is established with a gateway and a packet received, the router has to\ndetermine to which broker should the packet be forwarded. Two options exist:   The address is known and associated to a broker  The address is unknown   The former option will lead to a direct forwarding whereas the latter will require a network\ndiscovering / broadcasting (see the section  Address resolution and caching ).  Downlink communication  Because of the first version, the network will only supports devices of class A, the connexion\nbetween a gateway and a router would stay opened for a maximum of 2 seconds. The whole process\nis detailed in the  LoRaWAN specifications 1.0  - section 3.3 Receive Windows. In few\nwords though, after having emitted messages, a class A node will open two short receive windows\nand will allow incoming messages from a gateway. Windows are opened exactly one and two seconds\nafter the packet's emission. Sending packet at the right time is part of the gateway\nresponsibility, however, scheduling the emission is part of the network's one.   If any command or data have to be sent to the node, it has to be done precisely during one of\nthis two windows. More details about commands are given in the section related to the\nNetwork Server. Incidentally, only one of the two windows is available, meaning that sending\nthrough the first window will cause the second one to never be opened.     Receive Windows   Having said that, a downlink communication could be initiated by either an Application or a\nNetwork Server in response of an uplink message from a device. The role of a router is to\nforward those messages, not to trigger or schedule them.  Address resolution and caching  A router has a configured list of brokers addresses as well as a local cache associating device\nadresses to brokers. Entries of the cache get invalidated at regular interval (to determine\nduring testing or by computing), meaning that they are removed from the cache. \nWhen receiving a message, the router is in charge of looking into its local cache to determine\nwether or not a broker is known for the related node and segment. This is done by broadcasting a\nmessage to each known broker and by listening to their answers for the given message.   The router then stores each broker able to handle messages coming from the given node. However,\nbecause:   Handlers may register after a node emits a signal to brokers  A broker might not be available at the moment the broadcasting is done  Two node addresses are in collision   The cache has to be invalidated to allow the network to recover a consistent state. Such that\nno mapping between an address and a broker is settled forever after a first broadcast. However,\nwhen an address is known and is not invalidated, any issue listed above will remain until the\nnext invalidation.", 
            "title": "Role"
        }, 
        {
            "location": "/router/#decoupling", 
            "text": "In order to communicate with the outside world, we'll split the router in three parts:    The core router  An uplink adapter  A downlink adapter   The idea is to avoid to tightly couple the router core features with the way it is\ncommunicating. By doing such a separation of concerns, we allow the router to evolve and change\nits communication protocol at any moment, without any impact on the core mechanisms. Thus, as\nlong as the adapters remain compliant to a given interface they can be switched on demand.   All three components will share a common representation of a packet tagged with a version\nnumber. As long as all component use compatible representation of a packet, they sould be able\nto communicate.   Packets are  json  structure with the following structure:  {\n     time :  String ,\n     tmst :  Number ,\n     freq :  Number ,\n     chan :  Number ,\n     rfch :  Number ,\n     stat :  Number ,\n     modu :  String ,\n     datr :  Number , // In case of GFSK modulation\n     datr :  String , // In case of LoRa modulation\n     codr :  String ,\n     rssi :  Number ,\n     lsnr :  Number ,\n     size :  Number ,\n     data :  String \n}  More information about the meaning of those fields could be found in the  semtech protocol\ndescription .", 
            "title": "Decoupling"
        }, 
        {
            "location": "/router/#uplink-adapter", 
            "text": "We consider the following methods for the Uplink adapter (hereby known as  UpAdapter ):  -- Notify the gateway that the given packet has been received\nack :: UpAdapter, Packet -  Unit\nack (adapter, packet)\n\n-- Send a downlink packet to a gateway\nforward :: UpAdapter, Packet -  Unit\nforward (adapter, packet)  The uplink adapter is thereby in charge of queuing incoming packets, and trigger the router to\nhandle them properly. Because data coming from a gateway aren't formatted in the right way and\nalso because a gateway might send several packets through the same message, it is under the\nuplink adapter responsability to decode and interpret the data accordingly.", 
            "title": "Uplink adapter"
        }, 
        {
            "location": "/router/#downlink-adapter", 
            "text": "We consider the following methods for the Downlink adapter (hereby known as  DownAdapter ):  -- Send a packet to every available brokers. This method should trigger \n-- back some calls on the router to inform the router about which Broker \n-- are indeed responsible for the Packet.\nbroadcast :: DownAdapter, Packet -  Unit\nbroadcast (adapter, packet)\n\n-- Forward an uplink packet to a list of brokers using their addresses\nforward :: DownAdapter, BrokerAddr[], Packet -  Unit\nforward (adapter, [broAddr1, broAddr2], packet)  The downlink adapter should implement mechanism to handle network discovering ( broadcast ).\nBasically, this will be done when there is no known broker for a given packet. The downlink\nadapter is thereby in charge of registering device addresses to the core router once brokers\nhave been discovered.", 
            "title": "Downlink adapter"
        }, 
        {
            "location": "/router/#core", 
            "text": "The core router (hereby known as  Router ) handle all the router logic. It also supplies a\nconcise interface to allow both adapters to trigger actions. Any error or success from both\nadapters could trigger one of the following method.  -- Ask the router to handle a specific error. \nhandleError :: Router, Error -  Unit\nhandleError (router, err)\n\n-- Handle an incoming uplink packet\nhandleUplink :: Router, Packet -  Unit\nhandleUplink (router, packet)\n\n-- Handle an incoming downlink packet\nhandleDownlink :: Router, Packet -  Unit\nhandleDownlink (router, packet)\n\n-- Register a bunch of brokers address for a given device\nregisterDevice :: Router, DeviceAddr, BrokerAddr[] -  Unit\nregisterDevice (router, devAddr, [broAddr1, broAddr2])  The  handleError  method gives adapters a way to notify the router of an unresolved transaction\nor an incorrect behavior from the network. Errors are detailed below and should be explicit\nenough to allow the router to recover from it.", 
            "title": "Core"
        }, 
        {
            "location": "/router/#errors", 
            "text": "Any error coming from any router's components should provide the following information:   a name / identifier   a date (the moment it happens)  a message / description  the packet or data manipulated if any   A given error will thus provide methods that reflect those attributes:  -- Retrieve the error's name\nname :: Error -  String\nname (err)\n\n-- Retrieve the error's creation date\ndate :: Error -  Date|String\ndate (err) \n\n-- Retrieve the error's message\nmessage :: Error -  String\nmessage (err)\n\n-- Retrieve the error's data\nparams :: Error -  a\nparams (err)  Errors types the router may encounter are listed right below. This list isn't settled and is\nlikely to grow during the development. However, it gives an overview of referenced errors. By\nconvention, all error names are written in  snake_case .     name  description      invalid_packet  The given packet has a bad format    connection_lost  The connection with a recipient has been lost    no_response  No response received from a recipient    unable_forward_up  Unable to forward a packet (uplink)    unable_forward_down  Unable to forward a packet (downlink)", 
            "title": "Errors"
        }, 
        {
            "location": "/broker/", 
            "text": "Broker\n\n\nRole\n\n\nBrokers constitute the heart of the network. They hold the logic that makes every other\ncomponent work together (routers, network servers and handlers). They play a role of mediator,\nmaking sure that packets are correct and handling communications between other components. To\neach broker is associated a given network server with which it is working closely. We can see\nthe network server as external ressources of computing and storage to which a broker could\nrefer at any time. \n\n\nTherefore, a broker is in charge of a set of nodes. This is a 1-to-1 relation meaning that a\nnode is controlled by a unique broker. There is for the moment no duplication or sharing\npossible. A broker does not have access to network servers different from the one it has been\nassigned. A node isn't shared and all packets coming from a given node end to the same\ngiven broker.\n\n\nBesides, a broker does not know any router by advance. The process is seemingly similar to the way\ngateways and routers are getting to know each others. A router will initiate a communication\ntoward a broker. After dealing with the communication, the broker may reply to the router and\nwill forget about its existence after that. Brokers are known from routers, like routers are\nknown from gateways. \n\n\nOn the other hand, brokers communicate with a bunch of handlers that have registered themselves\nbeforehand. This way, when a device joins the network every broker has to communicate with its\nown handlers list to determine wether or not it has to handle packets incoming from that\ndevice. The previous assertion assumes that a given handler isn't registered to several\ndifferent brokers. \n\n\nRelations are schematically represented in the next diagram. \n\n\n\n\n\n\nBroker's relations\n\n\n\n\nFor each node it is in charge of, the broker holds a network session key associated to the node.\nIt is thereby able to check the integrity of the packet by doing a \nMIC check\n. The process is\ndetailed in the \nLoRaWAN specifications\n - section 4.4 Message Integrity Code (MIC). \n\n\nDepending of the packet's nature, the broker might communicate with either its network server\nor a registered handler. Part of the packet's message contains a \nMAC header\n \nMHDR\n which is not\nencrypted and gives details about the nature of packet's nature (cf the \npayload\ncheatsheet\n). Thus, for any command (\nFPort\n set to \n0\n) the broker would\nforward the action to its network server. Otherwise, the packet is forwarded to the right\nhandler. \n\n\nUplink communications\n\n\nA broker receives transmissions from routers. Transmissions have two aspects:\n\n\n\n\nDiscovering message\n\n\nDirect message\n\n\n\n\nDiscovering messages are sent when a router is trying to identify \n\n\nDownlink communication\n\n\nNetwork Commands", 
            "title": "Broker"
        }, 
        {
            "location": "/broker/#broker", 
            "text": "", 
            "title": "Broker"
        }, 
        {
            "location": "/broker/#role", 
            "text": "Brokers constitute the heart of the network. They hold the logic that makes every other\ncomponent work together (routers, network servers and handlers). They play a role of mediator,\nmaking sure that packets are correct and handling communications between other components. To\neach broker is associated a given network server with which it is working closely. We can see\nthe network server as external ressources of computing and storage to which a broker could\nrefer at any time.   Therefore, a broker is in charge of a set of nodes. This is a 1-to-1 relation meaning that a\nnode is controlled by a unique broker. There is for the moment no duplication or sharing\npossible. A broker does not have access to network servers different from the one it has been\nassigned. A node isn't shared and all packets coming from a given node end to the same\ngiven broker.  Besides, a broker does not know any router by advance. The process is seemingly similar to the way\ngateways and routers are getting to know each others. A router will initiate a communication\ntoward a broker. After dealing with the communication, the broker may reply to the router and\nwill forget about its existence after that. Brokers are known from routers, like routers are\nknown from gateways.   On the other hand, brokers communicate with a bunch of handlers that have registered themselves\nbeforehand. This way, when a device joins the network every broker has to communicate with its\nown handlers list to determine wether or not it has to handle packets incoming from that\ndevice. The previous assertion assumes that a given handler isn't registered to several\ndifferent brokers.   Relations are schematically represented in the next diagram.     Broker's relations   For each node it is in charge of, the broker holds a network session key associated to the node.\nIt is thereby able to check the integrity of the packet by doing a  MIC check . The process is\ndetailed in the  LoRaWAN specifications  - section 4.4 Message Integrity Code (MIC).   Depending of the packet's nature, the broker might communicate with either its network server\nor a registered handler. Part of the packet's message contains a  MAC header   MHDR  which is not\nencrypted and gives details about the nature of packet's nature (cf the  payload\ncheatsheet ). Thus, for any command ( FPort  set to  0 ) the broker would\nforward the action to its network server. Otherwise, the packet is forwarded to the right\nhandler.   Uplink communications  A broker receives transmissions from routers. Transmissions have two aspects:   Discovering message  Direct message   Discovering messages are sent when a router is trying to identify   Downlink communication  Network Commands", 
            "title": "Role"
        }, 
        {
            "location": "/networkserver/", 
            "text": "", 
            "title": "Network Server"
        }, 
        {
            "location": "/handler/", 
            "text": "", 
            "title": "Handler"
        }, 
        {
            "location": "/development/", 
            "text": "", 
            "title": "Development"
        }
    ]
}