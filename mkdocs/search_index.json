{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\nForeword\n\n\nThis document hereby refers to the content of the whole website. Any contributor is welcomed\nand could give a hand in several manners:\n\n\n\n\nLooking for and correcting typos\n\n\nAdd relevant and non redundant information\n\n\nComplete a part marked as //TODO\n\n\n\n\nRegardless of what you'll attempt, make sure to check \nthe issues list on\nGitHub\n before doing anything\n. Thus, if nobody is already working on something\nrelated, open an issue with a clear and concise title and briefly explain your incoming changes\nin the description. Then, fork the project, do your work, and create a Pull Request on the\noriginal repository. \n\n\nTo sum up:\n\n\n\n\nCheck \nGitHub issues\n\n\nOpen a new issue if no one exist\n\n\nFork the repository\n\n\nCreate a Pull Request once you're done\n\n\n\n\nThanks a lot !\n\n\nComponents\n\n\nThe following document describe the specifications for The Things Network's Architecture\nversion 1. These specifications focus on the network architecture which includes 4 kinds of\ncomponents:\n\n\n\n\nRouters \n\n\nBrokers\n\n\nNetwork Servers\n\n\nHandlers\n\n\n\n\nIncidentally, those components are interacting with other external entities on which we have -\nif any - only few controls:\n\n\n\n\nNodes (also known as end-devices)\n\n\nGateways\n\n\nApplications\n\n\n\n\n\n\n\n\nNetwork components\n\n\n\n\nNode\n\n\nNodes or end-devices refer to one end of the chain. Devices emit signals using\n\nLoRa\n modulation and frequency range towards Gateways. They are split into\n3 classes: \n\n\n\n\nA\n: Cannot receive any data from the network unless they've initiated the communication\n\n\nB\n: Can receive data from the network at precisely scheduled windows (Beacons)\n\n\nC\n: Can receive data at any time from the network\n\n\n\n\nIncidentally, class A requires less power than B which requires less power than C. \nAn end-device has an address either assigned by the Network or self-defined. An end-device\nalso has a specific secret application session key and a network session key \n\n\nThese specifications primarly focus on the class A. Future network versions will implement\nmechanisms to handle class B and class C but they are irrevelant with the current document.\n\n\nGateway\n\n\nGateways might be seen as a way to transform multiple messages emitters into one much more\ndemanding emitter. Therefore, a Gateway gathers \nLoRa\n signals coming from a\nbunch of near end-devices. A given device does not need to know the nearest gateways, nor it\nhas to communicate with a specific one - signals are simply broadcasted into the wild open. \n\n\nGateways receive signals which reach them, and forward the message to a dedicated Router. The\nData could be either a sensor result or a specific network command such as a connection\nrequest. A Gateway actually send incoming packets to a router after having wrapped each of them\ninto a \njson\n structure holding meta-data about the Gateway itself (such as Gateway's\nidentifier, a timestamp and GPS coordinates if available).\n\n\nGateways can also emit packets coming from the network toward a Node using the \nLoRa\ntechnology\n. In fact, Gateways are in charge of taking care of emission at a\nscheduled time defined by the network meaning that the network is able to send packets to\nGateways at any moment, regardless of their emission time (see more about the two-windows\nresponse mechanism //TODO add a link). \n\n\nApplication\n\n\nRouter\n\n\nRouters are entry points of the network from Nodes perspective. A Router receives packets\ngathered by some Gateways and initially transmitted by Nodes. Then, it forwards those packets\nto one or several Brokers. The communication is seemingly bi-directional: Routers may also\ntransfer packets from Broker to Gateways. \n\n\n\n\n\n\nUplink forwarding\n\n\n\n\nBroker\n\n\nBrokers have a global vision of a network's part. They are in charge of several nodes, meaning\nthat they will handle packets coming from those nodes (thereby, they are able to tell to\nRouters if they can handle a given packet). Several Routers may send packets coming from the\nsame end-device (shared by several segments / Gateways), all duplicates are managed by the\nBroker and are sent to a corresponding Handler.\n\n\nA Broker is thereby able to check the integrity of a packet and is closely communicating with a\nNetwork Server in order to administrate the related device. As an order of magnitude, Brokers\nare designed to be in charge of a whole country or region (if the region has enough activity to\ndeserve a dedicated Broker).\n\n\nNetwork Server\n\n\nNetwork servers are processing \nMAC\n commands emitted by end-devices as well as taking care\nof the data rates and the frequency of the devices. Network Servers would emit commands to\noptimize the network by adjusting end-devices data rates / frequencies unless the node is\nrequesting to keep its configuration as is. \n\n\nFor the moment, a single Network Server will be associated for each Broker. No communication\nmechanisms between Network Servers is planned for the first version. Also, it won't be possible\nfor a Broker to query another Network Server than the one it has been assigned to. Those\nfeatures might be part of a second version. \n\n\nHandler\n\n\nHandlers materialize the entry point to the network for client Applications. They are secure\nreferees which encode and decode data coming from application before transmitting them to a\nBroker of the network. Therefore, they are in charge of handling applications secret keys and\nonly communicate an application id to Brokers (as well as a specific network session key,\ndescribed in further sections). This way, the whole chain is able to forward a packet to the\ncorresponding Handler without having any information about either the recipient (but a\nmeaningless id) or the content. \n\n\nBecause a given Handler is able to decrypt the data payload of a given packet, it could\nalso implement mechanisms such as Geolocation and send to the corresponding application some\ninteresting meta-data.\n\n\nA Handler could be either part of an application or a standalone trusty server on which\napplication may register. The Things Network will provide Handlers as part of the whole network\nbut - and this is true for any component - anyone could create its own implementation as long\nas it is compliant to the following specifications.\n\n\n\n\n\n\nUplink to an Application", 
            "title": "Overview"
        }, 
        {
            "location": "/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/#foreword", 
            "text": "This document hereby refers to the content of the whole website. Any contributor is welcomed\nand could give a hand in several manners:   Looking for and correcting typos  Add relevant and non redundant information  Complete a part marked as //TODO   Regardless of what you'll attempt, make sure to check  the issues list on\nGitHub  before doing anything . Thus, if nobody is already working on something\nrelated, open an issue with a clear and concise title and briefly explain your incoming changes\nin the description. Then, fork the project, do your work, and create a Pull Request on the\noriginal repository.   To sum up:   Check  GitHub issues  Open a new issue if no one exist  Fork the repository  Create a Pull Request once you're done   Thanks a lot !", 
            "title": "Foreword"
        }, 
        {
            "location": "/#components", 
            "text": "The following document describe the specifications for The Things Network's Architecture\nversion 1. These specifications focus on the network architecture which includes 4 kinds of\ncomponents:   Routers   Brokers  Network Servers  Handlers   Incidentally, those components are interacting with other external entities on which we have -\nif any - only few controls:   Nodes (also known as end-devices)  Gateways  Applications     Network components", 
            "title": "Components"
        }, 
        {
            "location": "/#node", 
            "text": "Nodes or end-devices refer to one end of the chain. Devices emit signals using LoRa  modulation and frequency range towards Gateways. They are split into\n3 classes:    A : Cannot receive any data from the network unless they've initiated the communication  B : Can receive data from the network at precisely scheduled windows (Beacons)  C : Can receive data at any time from the network   Incidentally, class A requires less power than B which requires less power than C. \nAn end-device has an address either assigned by the Network or self-defined. An end-device\nalso has a specific secret application session key and a network session key   These specifications primarly focus on the class A. Future network versions will implement\nmechanisms to handle class B and class C but they are irrevelant with the current document.", 
            "title": "Node"
        }, 
        {
            "location": "/#gateway", 
            "text": "Gateways might be seen as a way to transform multiple messages emitters into one much more\ndemanding emitter. Therefore, a Gateway gathers  LoRa  signals coming from a\nbunch of near end-devices. A given device does not need to know the nearest gateways, nor it\nhas to communicate with a specific one - signals are simply broadcasted into the wild open.   Gateways receive signals which reach them, and forward the message to a dedicated Router. The\nData could be either a sensor result or a specific network command such as a connection\nrequest. A Gateway actually send incoming packets to a router after having wrapped each of them\ninto a  json  structure holding meta-data about the Gateway itself (such as Gateway's\nidentifier, a timestamp and GPS coordinates if available).  Gateways can also emit packets coming from the network toward a Node using the  LoRa\ntechnology . In fact, Gateways are in charge of taking care of emission at a\nscheduled time defined by the network meaning that the network is able to send packets to\nGateways at any moment, regardless of their emission time (see more about the two-windows\nresponse mechanism //TODO add a link).", 
            "title": "Gateway"
        }, 
        {
            "location": "/#application", 
            "text": "", 
            "title": "Application"
        }, 
        {
            "location": "/#router", 
            "text": "Routers are entry points of the network from Nodes perspective. A Router receives packets\ngathered by some Gateways and initially transmitted by Nodes. Then, it forwards those packets\nto one or several Brokers. The communication is seemingly bi-directional: Routers may also\ntransfer packets from Broker to Gateways.     Uplink forwarding", 
            "title": "Router"
        }, 
        {
            "location": "/#broker", 
            "text": "Brokers have a global vision of a network's part. They are in charge of several nodes, meaning\nthat they will handle packets coming from those nodes (thereby, they are able to tell to\nRouters if they can handle a given packet). Several Routers may send packets coming from the\nsame end-device (shared by several segments / Gateways), all duplicates are managed by the\nBroker and are sent to a corresponding Handler.  A Broker is thereby able to check the integrity of a packet and is closely communicating with a\nNetwork Server in order to administrate the related device. As an order of magnitude, Brokers\nare designed to be in charge of a whole country or region (if the region has enough activity to\ndeserve a dedicated Broker).", 
            "title": "Broker"
        }, 
        {
            "location": "/#network-server", 
            "text": "Network servers are processing  MAC  commands emitted by end-devices as well as taking care\nof the data rates and the frequency of the devices. Network Servers would emit commands to\noptimize the network by adjusting end-devices data rates / frequencies unless the node is\nrequesting to keep its configuration as is.   For the moment, a single Network Server will be associated for each Broker. No communication\nmechanisms between Network Servers is planned for the first version. Also, it won't be possible\nfor a Broker to query another Network Server than the one it has been assigned to. Those\nfeatures might be part of a second version.", 
            "title": "Network Server"
        }, 
        {
            "location": "/#handler", 
            "text": "Handlers materialize the entry point to the network for client Applications. They are secure\nreferees which encode and decode data coming from application before transmitting them to a\nBroker of the network. Therefore, they are in charge of handling applications secret keys and\nonly communicate an application id to Brokers (as well as a specific network session key,\ndescribed in further sections). This way, the whole chain is able to forward a packet to the\ncorresponding Handler without having any information about either the recipient (but a\nmeaningless id) or the content.   Because a given Handler is able to decrypt the data payload of a given packet, it could\nalso implement mechanisms such as Geolocation and send to the corresponding application some\ninteresting meta-data.  A Handler could be either part of an application or a standalone trusty server on which\napplication may register. The Things Network will provide Handlers as part of the whole network\nbut - and this is true for any component - anyone could create its own implementation as long\nas it is compliant to the following specifications.    Uplink to an Application", 
            "title": "Handler"
        }, 
        {
            "location": "/router/", 
            "text": "Router\n\n\nRole\n\n\nThe router's role is straightforward; It has to transfer packet coming from an emitter to the\nright recipient. The emitter and the recipient could be either:\n\n\n\n\nA gateway and a broker\n\n\nA broker and a gateway\n\n\n\n\nThis implies the router is able to interact with gateways and brokers in a bi-directional\nway. Let's distinguish communications the following way:\n\n\n\n\nUplink communication (from a gateway to one or several brokers)\n\n\nDownlink communication (from a broker to a gateway)\n\n\n\n\nCommunications protocols used between, on the one hand, gateways and the router (uplink) and,\non the other hand, the router and brokers (downlink) don't have to be identical. \n\n\nBoth communication process have their own characteristics and behavior, they will be detailed\nseparately. \n\n\nUplink communication\n\n\nA given gateway will be connected to a router of its choice, meaning that the gateway is\nconfigured to interact with that precise router. A router nevertheless might received\ncommunication from several gateways. Thus, gateways are completely unknown from a router - and\nwould remain unknown during the router lifecycle.\n\n\nA router is thereby a machine on which gateway will attempt to connect. This assumes that the\nrouter is accessible via a static IP address or solvable through a DNS service. The whole\nprotocol used by gateways can be found \nhere\n and could be sum up the\nfollowing ways:\n\n\n\n\nGateways initiate communication with a router\n\n\nGateways send data using a json structure and containing one or several packets\n\n\nThe router acknowledge reception of data\n\n\nGateways could be protected by a firewall or could use a NAT, routers cannot initiate communications\n\n\nGateways might trigger and pull the router periodically to keep a connexion open\n\n\n\n\nDownlink communication\n\n\nAs for the first version, the network will only supports devices of class A, the connexion\nbetween a gateway and a router would stay opened for a maximum of 2 seconds. The whole process\nis detailed in the \nLoRaWAN specifications 1.0\n - section 3.3 Receive Windows. In few\nwords though, after having emitted messages, a class A node will open two short receive windows\nand allow incoming messages from a gateway. Windows are opened exactly one and two seconds\nafter the packet's emission. Sending packet at the right time is part of the gateway\nresponsibility, however, scheduling the emission is part of the network's one. \n\n\nIf any command or data have to be sent to the node, it has to be done precisely during one of\nthis two windows. More details about commands are given in the section related to the\nNetwork Server. Incidentally, only one of the two windows is available, meaning that sending\nthrough the first window will cause the second one to never be opened. \n\n\n\n\n\n\nReceive Windows\n\n\n\n\nHaving said that, a downlink communication could be initiated by either an Application or a\nNetwork Server in response of an uplink message from a device. The role of a router is to\nforward those messages, not to trigger or schedule them.\n\n\nRouter decoupling\n\n\nIn order to communicate with the outside world, we'll split the router in three parts: \n\n\n\n\nThe core router\n\n\nAn uplink adapter\n\n\nA downlink adapter\n\n\n\n\nThe idea is to avoid to tighly couple the router core features with the way it is\ncommunicating. By doing such a separation of concerns, we allow the router to evolve and change\nits communication protocol at any moment, without any impact on the core mechanisms. Thus, as\nlong as the adapters remain compliant to a given interface they can be switched on demand. \n\n\nAll three components will share a common representation of a packet tagged with a version\nnumber. As long as all component use compatible representation of a packet, they sould be able\nto communicate. \n\n\nPackets are \njson\n structure with the following structure:\n\n\n{\n    \ntime\n: \nString\n,\n    \ntmst\n: \nNumber\n,\n    \nfreq\n: \nNumber\n,\n    \nchan\n: \nNumber\n,\n    \nrfch\n: \nNumber\n,\n    \nstat\n: \nNumber\n,\n    \nmodu\n: \nString\n,\n    \ndatr\n: \nNumber\n, // In case of GFSK modulation\n    \ndatr\n: \nString\n, // In case of LoRa modulation\n    \ncodr\n: \nString\n,\n    \nrssi\n: \nNumber\n,\n    \nlsnr\n: \nNumber\n,\n    \nlsnr\n: \nNumber\n,\n    \nsize\n: \nNumber\n,\n    \ndata\n: \nString\n\n}\n\n\n\n\nMore information about the meaning of those fields could be found in the \nsemtech protocol\ndescription\n.\n\n\nUplink adapter\n\n\nWe consider the following methods for the Uplink adapter (hereby known as \nUpAdapter\n):\n\n\n-- Notify the gateway that the given packet has been received\nack :: UpAdapter, Packet -\n Unit\nack (adapter, packet)\n\n-- Send a downlink packet to a gateway\nforward :: UpAdapter, Packet -\n Unit\nforward (adapter, packet)\n\n\n\n\nThe uplink adapter is thereby in charge of queuing incoming packet, and trigger the router to\nhandle them properly. Because data coming from a gateway aren' formatted in the right way and\nalso because a gateway might send several packets through the same message, it is under the\nuplink adapter responsability to decode and interpret the data accordingly. \n\n\nDownlink adapter\n\n\nWe consider the following methods for the Downlink adapter (hereby known as \nDownAdapter\n):\n\n\n-- Send a packet to every available brokers. This method should trigger \n-- back some calls on the router to inform the router about which Broker \n-- are indeed responsible for the Packet.\nbroadcast :: DownAdapter, Packet -\n Unit\nbroadcast (adapter, packet)\n\n-- Forward an uplink packet to a list of brokers using their addresses\nforward :: DownAdapter, BrokerAddr[], Packet -\n Unit\nforward (adapter, [broAddr1, broAddr2], packet)\n\n\n\n\nThe downlink adapter should implement mechanism to handle network discovering (\nbroadcast\n).\nBasically, this will be done when there is no known broker for a given packet. The downlink\nadapter is thereby in charge of registering device addresses to the core router once brokers\nhave been discovered. \n\n\nCore router\n\n\nThe core router (hereby known as \nRouter\n) handle all the router logic. It also supplies a\nconcise interface to allow both adapter to trigger actions. Any error or success from both\nadapter might trigger one of the following method.\n\n\n-- Ask the router to handle a specific error. \nhandleError :: Router, Error -\n Unit\nhandleError (router, e)\n\n-- Handle an incoming uplink packet\nhandleUplink :: Router, Packet -\n Unit\nhandleUplink (router, packet)\n\n-- Handle an incoming downlink packet\nhandleDownlink :: Router, Packet -\n Unit\nhandleDownlink (router, packet)\n\n-- Register a bunch of brokers address for a given device\nregisterDevice :: Router, DeviceAddr, BrokerAddr[] -\n Unit\nregisterDevice (router, devAddr, [broAddr1, broAddr2])\n\n\n\n\nThe \nhandleError\n method gives adapter a way to notify the router of an unresolved transaction\nor an incorrect behavior from the network. Errors are detailed below and should be explicit\nenough to allow the router to recover from it.", 
            "title": "Router"
        }, 
        {
            "location": "/router/#router", 
            "text": "", 
            "title": "Router"
        }, 
        {
            "location": "/router/#role", 
            "text": "The router's role is straightforward; It has to transfer packet coming from an emitter to the\nright recipient. The emitter and the recipient could be either:   A gateway and a broker  A broker and a gateway   This implies the router is able to interact with gateways and brokers in a bi-directional\nway. Let's distinguish communications the following way:   Uplink communication (from a gateway to one or several brokers)  Downlink communication (from a broker to a gateway)   Communications protocols used between, on the one hand, gateways and the router (uplink) and,\non the other hand, the router and brokers (downlink) don't have to be identical.   Both communication process have their own characteristics and behavior, they will be detailed\nseparately.   Uplink communication  A given gateway will be connected to a router of its choice, meaning that the gateway is\nconfigured to interact with that precise router. A router nevertheless might received\ncommunication from several gateways. Thus, gateways are completely unknown from a router - and\nwould remain unknown during the router lifecycle.  A router is thereby a machine on which gateway will attempt to connect. This assumes that the\nrouter is accessible via a static IP address or solvable through a DNS service. The whole\nprotocol used by gateways can be found  here  and could be sum up the\nfollowing ways:   Gateways initiate communication with a router  Gateways send data using a json structure and containing one or several packets  The router acknowledge reception of data  Gateways could be protected by a firewall or could use a NAT, routers cannot initiate communications  Gateways might trigger and pull the router periodically to keep a connexion open   Downlink communication  As for the first version, the network will only supports devices of class A, the connexion\nbetween a gateway and a router would stay opened for a maximum of 2 seconds. The whole process\nis detailed in the  LoRaWAN specifications 1.0  - section 3.3 Receive Windows. In few\nwords though, after having emitted messages, a class A node will open two short receive windows\nand allow incoming messages from a gateway. Windows are opened exactly one and two seconds\nafter the packet's emission. Sending packet at the right time is part of the gateway\nresponsibility, however, scheduling the emission is part of the network's one.   If any command or data have to be sent to the node, it has to be done precisely during one of\nthis two windows. More details about commands are given in the section related to the\nNetwork Server. Incidentally, only one of the two windows is available, meaning that sending\nthrough the first window will cause the second one to never be opened.     Receive Windows   Having said that, a downlink communication could be initiated by either an Application or a\nNetwork Server in response of an uplink message from a device. The role of a router is to\nforward those messages, not to trigger or schedule them.", 
            "title": "Role"
        }, 
        {
            "location": "/router/#router-decoupling", 
            "text": "In order to communicate with the outside world, we'll split the router in three parts:    The core router  An uplink adapter  A downlink adapter   The idea is to avoid to tighly couple the router core features with the way it is\ncommunicating. By doing such a separation of concerns, we allow the router to evolve and change\nits communication protocol at any moment, without any impact on the core mechanisms. Thus, as\nlong as the adapters remain compliant to a given interface they can be switched on demand.   All three components will share a common representation of a packet tagged with a version\nnumber. As long as all component use compatible representation of a packet, they sould be able\nto communicate.   Packets are  json  structure with the following structure:  {\n     time :  String ,\n     tmst :  Number ,\n     freq :  Number ,\n     chan :  Number ,\n     rfch :  Number ,\n     stat :  Number ,\n     modu :  String ,\n     datr :  Number , // In case of GFSK modulation\n     datr :  String , // In case of LoRa modulation\n     codr :  String ,\n     rssi :  Number ,\n     lsnr :  Number ,\n     lsnr :  Number ,\n     size :  Number ,\n     data :  String \n}  More information about the meaning of those fields could be found in the  semtech protocol\ndescription .  Uplink adapter  We consider the following methods for the Uplink adapter (hereby known as  UpAdapter ):  -- Notify the gateway that the given packet has been received\nack :: UpAdapter, Packet -  Unit\nack (adapter, packet)\n\n-- Send a downlink packet to a gateway\nforward :: UpAdapter, Packet -  Unit\nforward (adapter, packet)  The uplink adapter is thereby in charge of queuing incoming packet, and trigger the router to\nhandle them properly. Because data coming from a gateway aren' formatted in the right way and\nalso because a gateway might send several packets through the same message, it is under the\nuplink adapter responsability to decode and interpret the data accordingly.   Downlink adapter  We consider the following methods for the Downlink adapter (hereby known as  DownAdapter ):  -- Send a packet to every available brokers. This method should trigger \n-- back some calls on the router to inform the router about which Broker \n-- are indeed responsible for the Packet.\nbroadcast :: DownAdapter, Packet -  Unit\nbroadcast (adapter, packet)\n\n-- Forward an uplink packet to a list of brokers using their addresses\nforward :: DownAdapter, BrokerAddr[], Packet -  Unit\nforward (adapter, [broAddr1, broAddr2], packet)  The downlink adapter should implement mechanism to handle network discovering ( broadcast ).\nBasically, this will be done when there is no known broker for a given packet. The downlink\nadapter is thereby in charge of registering device addresses to the core router once brokers\nhave been discovered.   Core router  The core router (hereby known as  Router ) handle all the router logic. It also supplies a\nconcise interface to allow both adapter to trigger actions. Any error or success from both\nadapter might trigger one of the following method.  -- Ask the router to handle a specific error. \nhandleError :: Router, Error -  Unit\nhandleError (router, e)\n\n-- Handle an incoming uplink packet\nhandleUplink :: Router, Packet -  Unit\nhandleUplink (router, packet)\n\n-- Handle an incoming downlink packet\nhandleDownlink :: Router, Packet -  Unit\nhandleDownlink (router, packet)\n\n-- Register a bunch of brokers address for a given device\nregisterDevice :: Router, DeviceAddr, BrokerAddr[] -  Unit\nregisterDevice (router, devAddr, [broAddr1, broAddr2])  The  handleError  method gives adapter a way to notify the router of an unresolved transaction\nor an incorrect behavior from the network. Errors are detailed below and should be explicit\nenough to allow the router to recover from it.", 
            "title": "Router decoupling"
        }, 
        {
            "location": "/broker/", 
            "text": "", 
            "title": "Broker"
        }, 
        {
            "location": "/networkserver/", 
            "text": "", 
            "title": "Network Server"
        }, 
        {
            "location": "/handler/", 
            "text": "", 
            "title": "Handler"
        }, 
        {
            "location": "/development/", 
            "text": "", 
            "title": "Development"
        }
    ]
}